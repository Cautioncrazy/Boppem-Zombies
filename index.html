<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Web of the Dead: Nacht Der Untoten Prototype</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            color: white;
            font-family: 'Courier New', Courier, monospace;
            touch-action: none;
        }
        canvas {
            display: block;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        .hud-element {
            position: absolute;
            text-shadow: 2px 2px 0 #000;
        }
        #score-display {
            top: 20px;
            left: 20px;
            font-size: 24px;
            color: #ffd700;
        }
        #round-display {
            bottom: 20px;
            left: 20px;
            font-size: 36px;
            color: #bd0000;
        }
        #ammo-display {
            bottom: 20px;
            right: 20px;
            text-align: right;
            font-size: 24px;
        }
        #interaction-prompt {
            top: 60%; /* Moved down slightly so it doesn't cover player */
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            display: none;
            text-align: center;
        }
        #damage-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: red;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
        }
        /* Mobile Controls */
        .touch-control {
            position: absolute;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            pointer-events: auto;
            display: none;
        }
        .joystick-knob {
            width: 40%;
            height: 40%;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            position: absolute;
            top: 30%;
            left: 30%;
            pointer-events: none;
        }
        #left-stick {
            bottom: 50px;
            left: 50px;
            width: 120px;
            height: 120px;
        }
        #right-stick {
            bottom: 50px;
            right: 50px;
            width: 120px;
            height: 120px;
        }
        #context-btn {
            bottom: 180px;
            right: 60px;
            width: 80px;
            height: 80px;
            background: rgba(0, 255, 0, 0.2);
            border-color: #0f0;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 30px;
            display: none;
        }
        #reload-btn {
            bottom: 180px;
            right: 160px; /* Left of context button */
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 0, 0.2);
            border-color: #ff0;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            display: none;
        }
        @media (hover: none) and (pointer: coarse) {
            .touch-control { display: block; }
            #context-btn { display: flex; }
            #reload-btn { display: flex; }
            #ammo-display { pointer-events: auto; } /* Allow clicking ammo to swap */
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div id="damage-overlay"></div>
        <div id="score-display" class="hud-element">Points: 0</div>
        <div id="round-display" class="hud-element">I</div>
        <div id="ammo-display" class="hud-element">
            <div id="weapon-name">M1911</div>
            <div id="ammo-count">7 / 32</div>
            <div style="font-size: 12px; color: #aaa;">(Tap to Swap)</div>
        </div>
        <div id="interaction-prompt" class="hud-element"></div>

        <div id="left-stick" class="touch-control"><div class="joystick-knob"></div></div>
        <div id="right-stick" class="touch-control"><div class="joystick-knob"></div></div>
        <div id="context-btn" class="touch-control">üñêÔ∏è</div>
        <div id="reload-btn" class="touch-control">‚Üª</div>
    </div>

    <script>
        /**
         * Web of the Dead: Nacht Der Untoten Prototype
         */

        // --- CONSTANTS ---
        const CONSTANTS = {
            PLAYER_SPEED: 200,
            PLAYER_RADIUS: 15,
            ZOMBIE_RADIUS: 15,
            BULLET_SPEED: 800,
            ZOMBIE_BASE_SPEED: 50,
            ZOMBIE_RUN_SPEED: 110,
            INTERACT_DISTANCE: 80,
            WALL_THICKNESS: 20,
        };

        // --- UTILS ---
        class SoundManager {
            constructor() {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            }
            play(type) {
                if (this.ctx.state === 'suspended') this.ctx.resume();
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain);
                gain.connect(this.ctx.destination);

                if (type === 'shoot') {
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(400, this.ctx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + 0.1);
                    gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.1);
                    osc.start();
                    osc.stop(this.ctx.currentTime + 0.1);
                } else if (type === 'hit') {
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(200, this.ctx.currentTime);
                    gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                    gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.05);
                    osc.start();
                    osc.stop(this.ctx.currentTime + 0.05);
                } else if (type === 'buy') {
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(600, this.ctx.currentTime);
                    osc.frequency.setValueAtTime(800, this.ctx.currentTime + 0.1);
                    gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                    gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.2);
                    osc.start();
                    osc.stop(this.ctx.currentTime + 0.2);
                } else if (type === 'reload') {
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(200, this.ctx.currentTime);
                    osc.frequency.linearRampToValueAtTime(400, this.ctx.currentTime + 0.2);
                    gain.gain.setValueAtTime(0.05, this.ctx.currentTime);
                    gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.3);
                    osc.start();
                    osc.stop(this.ctx.currentTime + 0.3);
                } else if (type === 'no') {
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(150, this.ctx.currentTime);
                    gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                    gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.2);
                    osc.start();
                    osc.stop(this.ctx.currentTime + 0.2);
                }
            }
        }
        const soundManager = new SoundManager();

        class Vector2 {
            constructor(x, y) { this.x = x || 0; this.y = y || 0; }
            add(v) { return new Vector2(this.x + v.x, this.y + v.y); }
            sub(v) { return new Vector2(this.x - v.x, this.y - v.y); }
            mul(s) { return new Vector2(this.x * s, this.y * s); }
            mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
            normalize() {
                const m = this.mag();
                return m === 0 ? new Vector2(0, 0) : new Vector2(this.x / m, this.y / m);
            }
            dist(v) { return this.sub(v).mag(); }
            copy() { return new Vector2(this.x, this.y); }
        }

        class Rect {
            constructor(x, y, w, h) { this.x=x; this.y=y; this.w=w; this.h=h; }
            intersects(other) {
                return this.x < other.x + other.w && this.x + other.w > other.x &&
                       this.y < other.y + other.h && this.y + other.h > other.y;
            }
            contains(point) {
                return point.x >= this.x && point.x <= this.x + this.w &&
                       point.y >= this.y && point.y <= this.y + this.h;
            }
            getCenter() {
                return new Vector2(this.x + this.w/2, this.y + this.h/2);
            }
        }

        function checkCircleRectCollision(circlePos, circleRadius, rect) {
            let testX = circlePos.x;
            let testY = circlePos.y;

            if (circlePos.x < rect.x) testX = rect.x;
            else if (circlePos.x > rect.x + rect.w) testX = rect.x + rect.w;

            if (circlePos.y < rect.y) testY = rect.y;
            else if (circlePos.y > rect.y + rect.h) testY = rect.y + rect.h;

            const distX = circlePos.x - testX;
            const distY = circlePos.y - testY;
            const distance = Math.sqrt((distX * distX) + (distY * distY));

            if (distance <= circleRadius) {
                return new Vector2(distX, distY).normalize().mul(circleRadius - distance);
            }
            return null;
        }

        // --- INPUT HANDLER ---
        class InputHandler {
            constructor() {
                this.keys = {};
                this.mouse = new Vector2(0, 0);
                this.mouseDown = false;
                this.justPressed = {};

                window.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;
                    if(!e.repeat) this.justPressed[e.code] = true;
                });
                window.addEventListener('keyup', (e) => this.keys[e.code] = false);
                window.addEventListener('mousemove', (e) => {
                    this.mouse.x = e.clientX;
                    this.mouse.y = e.clientY;
                });
                window.addEventListener('mousedown', () => this.mouseDown = true);
                window.addEventListener('mouseup', () => this.mouseDown = false);

                this.gamepadIndex = null;
                window.addEventListener("gamepadconnected", (e) => this.gamepadIndex = e.gamepad.index);
                window.addEventListener("gamepaddisconnected", () => this.gamepadIndex = null);

                this.leftStick = { active: false, vector: new Vector2() };
                this.rightStick = { active: false, vector: new Vector2() };
                this.setupTouchControls();
            }

            setupTouchControls() {
                const setupStick = (elementId, stickObj) => {
                    const el = document.getElementById(elementId);
                    if (!el) return;

                    const update = (touch) => {
                        const rect = el.getBoundingClientRect();
                        const centerX = rect.left + rect.width / 2;
                        const centerY = rect.top + rect.height / 2;
                        const maxDist = rect.width / 2;

                        const dx = touch.clientX - centerX;
                        const dy = touch.clientY - centerY;
                        const dist = Math.min(Math.sqrt(dx*dx + dy*dy), maxDist);
                        const angle = Math.atan2(dy, dx);

                        stickObj.vector.x = (Math.cos(angle) * dist) / maxDist;
                        stickObj.vector.y = (Math.sin(angle) * dist) / maxDist;

                        const knob = el.querySelector('.joystick-knob');
                        knob.style.transform = `translate(${stickObj.vector.x * maxDist}px, ${stickObj.vector.y * maxDist}px)`;
                    };

                    el.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        stickObj.active = true;
                        update(e.touches[0]);
                    }, { passive: false });
                    el.addEventListener('touchmove', (e) => {
                        e.preventDefault();
                        if (stickObj.active) update(e.touches[0]);
                    }, { passive: false });
                    el.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        stickObj.active = false;
                        stickObj.vector = new Vector2(0, 0);
                        el.querySelector('.joystick-knob').style.transform = `translate(0px, 0px)`;
                    });
                };

                setupStick('left-stick', this.leftStick);
                setupStick('right-stick', this.rightStick);

                const contextBtn = document.getElementById('context-btn');
                if (contextBtn) {
                    contextBtn.addEventListener('touchstart', (e) => { e.preventDefault(); this.keys['KeyF'] = true; this.justPressed['KeyF'] = true; });
                    contextBtn.addEventListener('touchend', (e) => { e.preventDefault(); this.keys['KeyF'] = false; });
                }

                const reloadBtn = document.getElementById('reload-btn');
                if (reloadBtn) {
                    reloadBtn.addEventListener('touchstart', (e) => { e.preventDefault(); this.keys['KeyR'] = true; });
                    reloadBtn.addEventListener('touchend', (e) => { e.preventDefault(); this.keys['KeyR'] = false; });
                }

                const ammoDisplay = document.getElementById('ammo-display');
                if (ammoDisplay) {
                    ammoDisplay.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        this.justPressed['Space'] = true;
                    });
                }
            }

            getMovementVector() {
                let move = new Vector2(0, 0);
                if (this.keys['KeyW']) move.y -= 1;
                if (this.keys['KeyS']) move.y += 1;
                if (this.keys['KeyA']) move.x -= 1;
                if (this.keys['KeyD']) move.x += 1;

                if (this.gamepadIndex !== null) {
                    const gp = navigator.getGamepads()[this.gamepadIndex];
                    if (gp) {
                        if (Math.abs(gp.axes[0]) > 0.1) move.x += gp.axes[0];
                        if (Math.abs(gp.axes[1]) > 0.1) move.y += gp.axes[1];
                    }
                }
                if (this.leftStick.active) move = this.leftStick.vector;
                if (move.mag() > 1) move = move.normalize();
                return move;
            }

            getAimVector(playerPos, cameraOffset) {
                let aim = this.mouse.sub(playerPos.sub(cameraOffset)).normalize();
                if (this.gamepadIndex !== null) {
                    const gp = navigator.getGamepads()[this.gamepadIndex];
                    if (gp && (Math.abs(gp.axes[2]) > 0.1 || Math.abs(gp.axes[3]) > 0.1)) {
                        aim = new Vector2(gp.axes[2], gp.axes[3]).normalize();
                    }
                }
                if (this.rightStick.active && this.rightStick.vector.mag() > 0.1) aim = this.rightStick.vector.normalize();
                return aim;
            }

            isFiring() {
                if (this.mouseDown) return true;
                if (this.gamepadIndex !== null) {
                    const gp = navigator.getGamepads()[this.gamepadIndex];
                    if (gp && gp.buttons[7].pressed) return true;
                }
                if (this.rightStick.active && this.rightStick.vector.mag() > 0.5) return true;
                return false;
            }

            isInteracting() {
                if (this.justPressed['KeyF']) return true;
                if (this.gamepadIndex !== null) {
                     const gp = navigator.getGamepads()[this.gamepadIndex];
                     if (gp && gp.buttons[2].pressed) return true;
                }
                return false;
            }

            resetJustPressed() { this.justPressed = {}; }
        }

        // --- GAME ENTITIES ---
        class Entity {
            constructor(x, y, radius, color) {
                this.pos = new Vector2(x, y);
                this.radius = radius;
                this.color = color;
                this.toBeRemoved = false;
            }
            update(dt) {}
            draw(ctx) {
                ctx.beginPath();
                ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
            }
        }

        class Bullet extends Entity {
            constructor(x, y, dir, damage, owner, splash) {
                super(x, y, 3, '#ffff00');
                this.vel = dir.mul(CONSTANTS.BULLET_SPEED);
                this.damage = damage;
                this.owner = owner;
                this.splash = splash || 0;
                this.lifeTime = 2.0;
            }
            update(dt, game) {
                this.pos = this.pos.add(this.vel.mul(dt));
                this.lifeTime -= dt;
                if (this.lifeTime <= 0) this.toBeRemoved = true;

                // Wall Collision
                game.map.walls.forEach(wall => {
                    if (checkCircleRectCollision(this.pos, this.radius, wall)) this.toBeRemoved = true;
                });

                // Zombie Collision
                if (!this.toBeRemoved) {
                    for (let zombie of game.zombies) {
                        if (this.pos.dist(zombie.pos) < this.radius + zombie.radius) {
                            if (this.splash > 0) {
                                // Splash Damage
                                game.zombies.forEach(z => {
                                    if (z.pos.dist(this.pos) < this.splash) {
                                        z.takeDamage(this.damage, game);
                                    }
                                });
                            } else {
                                zombie.takeDamage(this.damage, game);
                            }
                            this.toBeRemoved = true;
                            break; // 1 hit
                        }
                    }
                }
            }
        }

        class Weapon {
            constructor(config) {
                this.name = config.name;
                this.damage = config.damage;
                this.fireRate = config.fireRate;
                this.magSize = config.magSize;
                this.reserveMax = config.reserveMax;
                this.reloadTime = config.reloadTime;
                this.spread = config.spread;
                this.auto = config.auto;
                this.shotCount = config.shotCount || 1;
                this.splash = config.splash || 0;

                this.currentMag = this.magSize;
                this.reserve = this.reserveMax;

                this.lastFireTime = 0;
                this.reloading = false;
                this.reloadTimer = 0;
            }

            tryFire(game, player, time) {
                if (this.reloading) return;
                if (this.currentMag <= 0) {
                    this.reload();
                    return;
                }
                if (time - this.lastFireTime < this.fireRate) return;
                if (!this.auto && game.input.mouseDown && time - this.lastFireTime < 0.2) return; // Debounce manual

                this.currentMag--;
                this.lastFireTime = time;
                soundManager.play('shoot');

                // Spawn Bullet(s)
                for(let i=0; i<this.shotCount; i++) {
                    const spreadAngle = (Math.random() - 0.5) * this.spread;
                    const baseDir = new Vector2(Math.cos(player.angle), Math.sin(player.angle));
                    // Rotate baseDir by spreadAngle
                    const cos = Math.cos(spreadAngle);
                    const sin = Math.sin(spreadAngle);
                    const dir = new Vector2(baseDir.x * cos - baseDir.y * sin, baseDir.x * sin + baseDir.y * cos);

                    game.bullets.push(new Bullet(player.pos.x, player.pos.y, dir, this.damage, player, this.splash));
                }
            }

            reload() {
                if (this.reloading || this.currentMag === this.magSize || this.reserve === 0) return;
                this.reloading = true;
                this.reloadTimer = 0;
                soundManager.play('reload');
                console.log("Reloading...");
            }

            update(dt) {
                if (this.reloading) {
                    this.reloadTimer += dt;
                    if (this.reloadTimer >= this.reloadTime) {
                        this.finishReload();
                    }
                }
            }

            finishReload() {
                this.reloading = false;
                const needed = this.magSize - this.currentMag;
                const available = Math.min(needed, this.reserve);
                this.currentMag += available;
                this.reserve -= available;
            }
        }

        const WEAPONS_DATA = {
            'M1911': { name: 'M1911', damage: 20, fireRate: 0.2, magSize: 8, reserveMax: 32, reloadTime: 1.5, spread: 0.1, auto: false },
            'Kar98k': { name: 'Kar98k', damage: 100, fireRate: 1.0, magSize: 5, reserveMax: 50, reloadTime: 2.5, spread: 0.02, auto: false },
            'M1A1': { name: 'M1A1 Carbine', damage: 40, fireRate: 0.2, magSize: 15, reserveMax: 120, reloadTime: 2.0, spread: 0.05, auto: false },
            'Thompson': { name: 'Thompson', damage: 25, fireRate: 0.1, magSize: 20, reserveMax: 160, reloadTime: 2.0, spread: 0.15, auto: true },
            'DoubleBarrel': { name: 'Double-Barreled Shotgun', damage: 150, fireRate: 0.5, magSize: 2, reserveMax: 24, reloadTime: 3.0, spread: 0.4, auto: false, shotCount: 8 },
            'BAR': { name: 'BAR', damage: 50, fireRate: 0.15, magSize: 20, reserveMax: 140, reloadTime: 2.5, spread: 0.1, auto: true },
            'SawedOff': { name: 'Sawed-Off Shotgun', damage: 200, fireRate: 0.5, magSize: 2, reserveMax: 24, reloadTime: 3.0, spread: 0.5, auto: false, shotCount: 10 },
            'RayGun': { name: 'Ray Gun', damage: 1000, fireRate: 0.3, magSize: 20, reserveMax: 160, reloadTime: 3.0, spread: 0.0, auto: true, splash: 100 },
            'MG42': { name: 'MG42', damage: 30, fireRate: 0.05, magSize: 50, reserveMax: 300, reloadTime: 4.0, spread: 0.2, auto: true },
            'Browning': { name: 'Browning M1919', damage: 45, fireRate: 0.1, magSize: 50, reserveMax: 300, reloadTime: 4.0, spread: 0.15, auto: true },
            'Flamethrower': { name: 'Flamethrower', damage: 10, fireRate: 0.05, magSize: 100, reserveMax: 400, reloadTime: 4.0, spread: 0.3, auto: true, flame: true },
        };

        class Interactable {
            constructor(x, y, w, h) {
                this.rect = new Rect(x, y, w, h);
                this.prompt = "";
            }
            draw(ctx) {}
            interact(player, game) {}
            getCenter() { return this.rect.getCenter(); }
        }

        class Window extends Interactable {
            constructor(x, y, w, h, spawnPoint, enterPoint) {
                super(x, y, w, h);
                this.boards = 6;
                this.maxBoards = 6;
                this.spawnPoint = spawnPoint;
                this.enterPoint = enterPoint; // Point inside the room to guide zombie
                this.lastDamageTime = 0;
            }

            draw(ctx) {
                // Draw Frame (Outline)
                ctx.strokeStyle = '#444';
                ctx.lineWidth = 2;
                ctx.strokeRect(this.rect.x, this.rect.y, this.rect.w, this.rect.h);

                // Boards
                ctx.fillStyle = '#8B4513';
                const boardHeight = this.rect.h / this.maxBoards;
                for (let i = 0; i < this.boards; i++) {
                    ctx.fillRect(this.rect.x, this.rect.y + this.rect.h - (i+1)*boardHeight, this.rect.w, boardHeight - 2);
                }
            }

            interact(player, game) {
                if (this.boards < this.maxBoards) {
                    this.boards++;
                    game.score += 10;
                    soundManager.play('hit');
                    return "Repaired Board (+10)";
                }
                return "Window Fully Repaired";
            }

            damage(amount) {
                if (this.boards > 0 && Date.now() - this.lastDamageTime > 1000) {
                    this.boards -= amount;
                    this.lastDamageTime = Date.now();
                    if (this.boards < 0) this.boards = 0;
                    return true;
                }
                return false;
            }
        }

        class Door extends Interactable {
            constructor(x, y, w, h, cost, targetZoneId) {
                super(x, y, w, h);
                this.cost = cost;
                this.targetZoneId = targetZoneId;
                this.open = false;
            }
            draw(ctx) {
                if (this.open) return;
                ctx.fillStyle = '#553311'; // Debris color
                ctx.fillRect(this.rect.x, this.rect.y, this.rect.w, this.rect.h);
                // Draw Cost text
                ctx.fillStyle = 'white';
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`Cost: ${this.cost}`, this.rect.x + this.rect.w/2, this.rect.y + this.rect.h/2);
            }
            interact(player, game) {
                if (!this.open && game.score >= this.cost) {
                    game.score -= this.cost;
                    this.open = true;
                    game.map.unlockZone(this.targetZoneId);
                    soundManager.play('buy');
                    return `Opened ${this.targetZoneId}`;
                } else if (!this.open) {
                    soundManager.play('no');
                    return `Need ${this.cost} Points`;
                }
                return "";
            }
        }

        class WallBuy extends Interactable {
            constructor(x, y, w, h, weaponKey, cost) {
                super(x, y, w, h);
                this.weaponKey = weaponKey;
                this.cost = cost;
                this.weaponName = WEAPONS_DATA[weaponKey].name;
            }
            draw(ctx) {
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.strokeRect(this.rect.x, this.rect.y, this.rect.w, this.rect.h);
                ctx.fillStyle = 'white';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(this.weaponName, this.rect.x + this.rect.w/2, this.rect.y + this.rect.h/2 - 5);
                ctx.fillText(this.cost, this.rect.x + this.rect.w/2, this.rect.y + this.rect.h/2 + 15);
            }
            interact(player, game) {
                const existingWeapon = player.inventory.find(w => w.name === this.weaponName);
                if (existingWeapon) {
                    const ammoCost = Math.floor(this.cost / 2);
                    if (game.score >= ammoCost) {
                        game.score -= ammoCost;
                        existingWeapon.reserve = existingWeapon.reserveMax;
                        soundManager.play('buy');
                        return `Bought Ammo for ${this.weaponName}`;
                    }
                    soundManager.play('no');
                    return `Need ${ammoCost} for Ammo`;
                } else {
                    if (game.score >= this.cost) {
                        game.score -= this.cost;
                        const newWeapon = new Weapon(WEAPONS_DATA[this.weaponKey]);
                        if (player.inventory.length < 2) {
                            player.inventory.push(newWeapon);
                            player.currentWeaponIndex = player.inventory.length - 1;
                        } else {
                            player.inventory[player.currentWeaponIndex] = newWeapon;
                        }
                        soundManager.play('buy');
                        return `Bought ${this.weaponName}`;
                    }
                    soundManager.play('no');
                    return `Need ${this.cost} for ${this.weaponName}`;
                }
            }
        }

        class MysteryBox extends Interactable {
            constructor(x, y) {
                super(x, y, 80, 40);
                this.cost = 950;
                this.state = 'idle'; // idle, cycling, open
                this.cycleTimer = 0;
                this.displayWeapon = '?';
                this.selectedWeaponKey = null;
            }

            draw(ctx) {
                ctx.fillStyle = '#6A0DAD'; // Purple box
                ctx.fillRect(this.rect.x, this.rect.y, this.rect.w, this.rect.h);
                ctx.fillStyle = 'yellow';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';

                if (this.state === 'idle') {
                    ctx.fillText("?", this.rect.x + this.rect.w/2, this.rect.y + this.rect.h/2 + 5);
                } else if (this.state === 'cycling') {
                    ctx.fillText(this.displayWeapon, this.rect.x + this.rect.w/2, this.rect.y + this.rect.h/2 + 5);
                } else if (this.state === 'open') {
                    ctx.fillText(WEAPONS_DATA[this.selectedWeaponKey].name, this.rect.x + this.rect.w/2, this.rect.y + -10);
                }
            }

            interact(player, game) {
                if (this.state === 'idle') {
                    if (game.score >= this.cost) {
                        game.score -= this.cost;
                        this.state = 'cycling';
                        this.cycleTimer = 0;
                        soundManager.play('buy');
                        return "Mystery Box Activated";
                    }
                    soundManager.play('no');
                    return `Need ${this.cost} Points`;
                } else if (this.state === 'open') {
                    // Take Weapon
                    const newWeapon = new Weapon(WEAPONS_DATA[this.selectedWeaponKey]);
                    if (player.inventory.length < 2) {
                        player.inventory.push(newWeapon);
                        player.currentWeaponIndex = player.inventory.length - 1;
                    } else {
                        player.inventory[player.currentWeaponIndex] = newWeapon;
                    }
                    this.state = 'idle';
                    soundManager.play('buy');
                    return `Took ${newWeapon.name}`;
                }
                return "";
            }

            update(dt) {
                if (this.state === 'cycling') {
                    this.cycleTimer += dt;
                    if (this.cycleTimer % 0.1 < dt) { // Change display every 0.1s
                        const keys = Object.keys(WEAPONS_DATA);
                        this.displayWeapon = WEAPONS_DATA[keys[Math.floor(Math.random() * keys.length)]].name;
                    }
                    if (this.cycleTimer > 4.0) {
                        this.state = 'open';
                        const keys = Object.keys(WEAPONS_DATA);
                        this.selectedWeaponKey = keys[Math.floor(Math.random() * keys.length)];
                    }
                }
            }
        }

        class PowerUp extends Entity {
            constructor(x, y, type) {
                super(x, y, 15, '#00ff00');
                this.type = type; // 'nuke', 'insta', 'double', 'ammo'
                this.lifeTime = 30.0;
                this.blinkTimer = 0;
            }

            draw(ctx) {
                if (this.lifeTime < 5 && Math.floor(Date.now() / 200) % 2 === 0) return;

                ctx.beginPath();
                ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = '#00ff00';
                ctx.fill();
                ctx.fillStyle = 'white';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(this.type.toUpperCase(), this.pos.x, this.pos.y + 4);
            }

            update(dt) {
                this.lifeTime -= dt;
                if (this.lifeTime <= 0) this.toBeRemoved = true;
            }
        }

        class Player extends Entity {
            constructor(x, y) {
                super(x, y, CONSTANTS.PLAYER_RADIUS, '#0099ff');
                this.angle = 0;
                this.health = 100;
                this.maxHealth = 100;
                this.lastDamageTime = 0;

                this.inventory = [new Weapon(WEAPONS_DATA['M1911'])];
                this.currentWeaponIndex = 0;
            }

            get weapon() {
                return this.inventory[this.currentWeaponIndex];
            }

            switchWeapon() {
                if (this.inventory.length > 1) {
                    this.currentWeaponIndex = (this.currentWeaponIndex + 1) % this.inventory.length;
                    this.weapon.reloading = false; // Cancel reload on switch
                }
            }

            takeDamage(amount) {
                this.health -= amount;
                this.lastDamageTime = Date.now();
                if (this.health <= 0) {
                    this.health = 0;
                    console.log("Game Over");
                }
                this.updateDamageOverlay();
            }

            updateDamageOverlay() {
                const opacity = 1 - (this.health / this.maxHealth);
                const overlay = document.getElementById('damage-overlay');
                if (overlay) overlay.style.opacity = Math.max(0, Math.min(0.8, opacity));
            }

            update(dt, input, game) {
                // Weapon Update
                this.weapon.update(dt);
                if (input.isFiring()) {
                    this.weapon.tryFire(game, this, dt + game.lastTime/1000);
                }
                if (input.keys['KeyR'] || (input.gamepadIndex !== null && navigator.getGamepads()[input.gamepadIndex].buttons[2].pressed)) {
                    this.weapon.reload();
                }
                if (input.justPressed['Space'] || (input.gamepadIndex !== null && navigator.getGamepads()[input.gamepadIndex].buttons[3].pressed)) { // Triangle/Y switch
                     this.switchWeapon();
                     // Debounce handled by justPressed for Space, but Gamepad needs one
                }

                // Movement
                const moveDir = input.getMovementVector();
                let proposedPos = this.pos.add(moveDir.mul(CONSTANTS.PLAYER_SPEED * dt));

                // Wall Collision
                game.map.walls.forEach(wall => {
                    const collision = checkCircleRectCollision(proposedPos, this.radius, wall);
                    if (collision) {
                        proposedPos = proposedPos.add(collision);
                    }
                });

                // Door Collision (if closed)
                game.map.doors.forEach(door => {
                    if (!door.open) {
                        const collision = checkCircleRectCollision(proposedPos, this.radius, door.rect);
                        if (collision) proposedPos = proposedPos.add(collision);
                    }
                });

                this.pos = proposedPos;

                // Aiming
                const aimDir = input.getAimVector(this.pos, game.camera);
                this.angle = Math.atan2(aimDir.y, aimDir.x);

                // Interaction
                if (input.isInteracting()) {
                    let closest = null;
                    let minD = Infinity;
                    const interactables = [...game.map.windows, ...game.map.doors]; // Add wall buys later

                    interactables.forEach(obj => {
                        const d = this.pos.dist(obj.getCenter());
                        if (d < CONSTANTS.INTERACT_DISTANCE && d < minD) {
                            minD = d;
                            closest = obj;
                        }
                    });

                    if (closest) {
                        const msg = closest.interact(this, game);
                        if (msg) console.log(msg); // Placeholder for UI feedback
                    }
                }

                // Health Regen
                if (Date.now() - this.lastDamageTime > 5000 && this.health < this.maxHealth) {
                    this.health += 20 * dt;
                    if (this.health > this.maxHealth) this.health = this.maxHealth;
                    this.updateDamageOverlay();
                }
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.pos.x, this.pos.y);
                ctx.rotate(this.angle);

                // Body
                ctx.beginPath();
                ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Arms / Gun
                ctx.fillStyle = 'white';
                ctx.fillRect(0, -5, 25, 10);

                ctx.restore();
            }
        }

        class Zombie extends Entity {
            constructor(x, y, health, targetWindow) {
                super(x, y, CONSTANTS.ZOMBIE_RADIUS, '#00ff00');
                this.health = health;
                this.maxHealth = health;
                this.targetWindow = targetWindow;
                this.passedWindow = false;
                this.attackTimer = 0;
            }

            takeDamage(amount, game) {
                if (game.instaKill) amount = this.health;
                this.health -= amount;
                game.score += (game.doublePoints ? 20 : 10);
                if (this.health <= 0 && !this.toBeRemoved) {
                    this.toBeRemoved = true;
                    game.score += (game.doublePoints ? 120 : 60);
                    game.zombiesKilled++;

                    if (Math.random() < 0.05) { // 5% chance
                        const types = ['nuke', 'insta', 'double', 'ammo'];
                        const type = types[Math.floor(Math.random() * types.length)];
                        game.powerUps.push(new PowerUp(this.pos.x, this.pos.y, type));
                    }
                }
            }

            update(dt, game) {
                const player = game.player;
                let targetPos = player.pos;

                // Logic to handle window interaction
                if (!this.passedWindow && this.targetWindow) {
                    const distToWindow = this.pos.dist(this.targetWindow.getCenter());

                    if (this.targetWindow.boards > 0) {
                        // Go to window and attack
                        targetPos = this.targetWindow.getCenter();
                        if (distToWindow < 30) {
                            // Attack window
                            this.attackTimer += dt;
                            if (this.attackTimer > 2) { // 2 seconds to rip board
                                this.targetWindow.damage(1);
                                this.attackTimer = 0;
                            }
                            // Stop moving while attacking
                            return;
                        }
                    } else {
                        // Boards are gone, move through window
                        // Target a point just inside the room to ensure we pass through the wall gap
                        if (distToWindow < 30) {
                             this.passedWindow = true; // We are basically there
                        } else {
                            targetPos = this.targetWindow.getCenter();
                        }
                    }
                }

                const dir = targetPos.sub(this.pos).normalize();
                let speed = CONSTANTS.ZOMBIE_BASE_SPEED;
                // Simple scaling: if round > 5, run
                if (game.round >= 5) speed = CONSTANTS.ZOMBIE_RUN_SPEED;

                let move = dir.mul(speed * dt);
                let proposedPos = this.pos.add(move);

                // Zombie-Zombie Collision (Separation)
                game.zombies.forEach(z => {
                    if (z === this) return;
                    const d = this.pos.dist(z.pos);
                    if (d < this.radius * 2) {
                        const push = this.pos.sub(z.pos).normalize().mul(50 * dt);
                        proposedPos = proposedPos.add(push);
                    }
                });

                // Player Collision (Damage)
                const distToPlayer = this.pos.dist(player.pos);
                if (distToPlayer < this.radius + player.radius) {
                    this.attackTimer += dt;
                    if (this.attackTimer > 1.0) { // 1 hit per second
                         player.takeDamage(30);
                         this.attackTimer = 0;
                    }
                }

                // Wall Collision
                game.map.walls.forEach(wall => {
                    const collision = checkCircleRectCollision(proposedPos, this.radius, wall);
                    if (collision) proposedPos = proposedPos.add(collision);
                });

                // Window Collision (Only if boards up)
                // Actually, if boards are up, the window acts as a wall?
                // We handle this by zombie targeting the window center.
                // If we treat window as a wall, they can't pass.
                // We should check collision with window ONLY if we are NOT the zombie targeting it?
                // Or simply: Windows are not walls. Walls are walls.
                // But we split the walls. So there is a hole.
                // If boards > 0, we should treat it as solid for the player maybe?

                // Door Collision
                game.map.doors.forEach(door => {
                    if (!door.open) {
                        const collision = checkCircleRectCollision(proposedPos, this.radius, door.rect);
                        if (collision) proposedPos = proposedPos.add(collision);
                    }
                });

                this.pos = proposedPos;
            }
        }

        class GameMap {
            constructor() {
                this.walls = [];
                this.windows = [];
                this.doors = [];
                this.wallBuys = [];
                this.zones = {
                    'spawn': { unlocked: true },
                    'help': { unlocked: false },
                    'upstairs': { unlocked: false }
                };
                this.buildMap();
            }

            unlockZone(id) {
                if (this.zones[id]) this.zones[id].unlocked = true;
            }

            buildMap() {
                // SPAWN ROOM (0,0 to 800,600)
                // Left Wall with Window Gap (Window at 250-350)
                this.walls.push(new Rect(-20, 0, 20, 250)); // Left Top
                this.walls.push(new Rect(-20, 350, 20, 250)); // Left Bottom

                // Right Wall with Door Gap (Door at 250-350) and Window Gap (Window at 100-200)
                this.walls.push(new Rect(800, 0, 20, 100)); // Right Top
                this.walls.push(new Rect(800, 200, 20, 50)); // Right Mid (Between Window and Door)
                this.walls.push(new Rect(800, 350, 20, 250)); // Right Bottom

                // Bottom Wall with Window Gap (Window at 350-450)
                this.walls.push(new Rect(0, 600, 350, 20)); // Bottom Left
                this.walls.push(new Rect(450, 600, 350, 20)); // Bottom Right

                // Top Wall with Stairs Gap (Stairs at 350-450)
                this.walls.push(new Rect(0, -20, 350, 20)); // Top Left
                this.walls.push(new Rect(450, -20, 350, 20)); // Top Right

                // Windows
                this.windows.push(new Window(-10, 250, 20, 100, new Vector2(-50, 300))); // Left
                this.windows.push(new Window(350, 600, 100, 20, new Vector2(400, 650))); // Bottom
                this.windows.push(new Window(790, 100, 20, 100, new Vector2(850, 150))); // Right

                // Doors
                this.doors.push(new Door(800, 250, 20, 100, 1000, 'help')); // To Help Room
                this.doors.push(new Door(350, -20, 100, 20, 1000, 'upstairs')); // To Upstairs (Debris)

                // Wall Buys (Spawn)
                this.wallBuys.push(new WallBuy(780, 50, 20, 50, 'Kar98k', 200)); // Right Wall Top
                this.wallBuys.push(new WallBuy(100, 0, 60, 20, 'M1A1', 600)); // Top Wall

                // HELP ROOM (800, 0 to 1300, 600)
                this.walls.push(new Rect(800, -20, 500, 20)); // Top
                this.walls.push(new Rect(800, 600, 500, 20)); // Bottom
                this.walls.push(new Rect(1300, 0, 20, 600)); // Right

                this.wallBuys.push(new WallBuy(1280, 100, 20, 50, 'Thompson', 1200)); // Right Wall
                this.wallBuys.push(new WallBuy(1280, 400, 20, 50, 'DoubleBarrel', 1200)); // Right Wall

                // UPSTAIRS (0, -500 to 800, 0)
                this.walls.push(new Rect(-20, -500, 20, 500)); // Left
                this.walls.push(new Rect(800, -500, 20, 500)); // Right
                this.walls.push(new Rect(0, -520, 800, 20)); // Top

                this.wallBuys.push(new WallBuy(0, -250, 20, 50, 'BAR', 1800)); // Left Wall
                this.wallBuys.push(new WallBuy(780, -250, 20, 50, 'SawedOff', 1200)); // Right Wall

                // Mystery Box (Help Room)
                this.mysteryBox = new MysteryBox(1000, 100);
            }

            draw(ctx) {
                // Draw Floor/Background for Zones (Optional, for now just black/grey)

                // Draw Walls
                ctx.fillStyle = '#555';
                this.walls.forEach(w => ctx.fillRect(w.x, w.y, w.w, w.h));

                // Draw Windows
                this.windows.forEach(w => w.draw(ctx));

                // Draw Doors
                this.doors.forEach(d => d.draw(ctx));

                // Draw Wall Buys
                this.wallBuys.forEach(wb => wb.draw(ctx));

                // Draw Mystery Box
                this.mysteryBox.draw(ctx);
            }
        }

        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.resize();
                window.addEventListener('resize', () => this.resize());

                this.input = new InputHandler();
                this.map = new GameMap();
                this.player = new Player(400, 300); // Center of Spawn
                this.zombies = [];
                this.bullets = [];
                this.powerUps = [];
                this.camera = new Vector2(0, 0);

                this.score = 500;
                this.round = 1;
                this.zombiesToSpawn = 5;
                this.zombiesSpawned = 0;
                this.zombiesKilled = 0;
                this.roundState = 'spawning'; // spawning, waiting
                this.spawnTimer = 0;

                this.instaKill = false;
                this.instaKillTimer = 0;
                this.doublePoints = false;
                this.doublePointsTimer = 0;

                this.lastTime = 0;
                this.requestLoop();
            }

            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }

            spawnZombie() {
                // Pick random window from unlocked zones
                const unlockedWindows = this.map.windows.filter(w => {
                    // Simple check: is the window in an unlocked zone?
                    // For now, all windows are in Spawn which is unlocked.
                    // If we add windows to other zones, we need to check zone.unlocked.
                    return true;
                });

                const window = unlockedWindows[Math.floor(Math.random() * unlockedWindows.length)];
                if (window) {
                    const health = 100 * Math.pow(1.1, this.round - 1);
                    this.zombies.push(new Zombie(window.spawnPoint.x, window.spawnPoint.y, health, window));
                }
            }

            toRoman(num) {
                if (num >= 50) return "L" + this.toRoman(num - 50);
                if (num >= 40) return "XL" + this.toRoman(num - 40);
                if (num >= 10) return "X" + this.toRoman(num - 10);
                if (num >= 9) return "IX" + this.toRoman(num - 9);
                if (num >= 5) return "V" + this.toRoman(num - 5);
                if (num >= 4) return "IV" + this.toRoman(num - 4);
                if (num >= 1) return "I" + this.toRoman(num - 1);
                return "";
            }

            update(dt) {
                // PowerUp Timers
                if (this.instaKill) {
                    this.instaKillTimer -= dt;
                    if (this.instaKillTimer <= 0) this.instaKill = false;
                }
                if (this.doublePoints) {
                    this.doublePointsTimer -= dt;
                    if (this.doublePointsTimer <= 0) this.doublePoints = false;
                }

                // Mystery Box Update
                this.map.mysteryBox.update(dt);

                // Round Logic
                if (this.roundState === 'spawning') {
                    if (this.zombiesSpawned < this.zombiesToSpawn) {
                        this.spawnTimer += dt;
                        if (this.spawnTimer > 2.0) { // Spawn every 2s
                            this.spawnZombie();
                            this.spawnTimer = 0;
                            this.zombiesSpawned++;
                        }
                    } else if (this.zombies.length === 0) {
                        this.roundState = 'waiting';
                        this.spawnTimer = 0; // Use for delay between rounds
                    }
                } else if (this.roundState === 'waiting') {
                    this.spawnTimer += dt;
                    if (this.spawnTimer > 5.0) { // 5s break
                        this.round++;
                        this.zombiesToSpawn = Math.floor(5 * Math.pow(1.1, this.round - 1));
                        this.zombiesSpawned = 0;
                        this.roundState = 'spawning';
                    }
                }

                this.player.update(dt, this.input, this);

                // Bullet Update
                this.bullets.forEach(b => b.update(dt, this));
                this.bullets = this.bullets.filter(b => !b.toBeRemoved);

                // Zombie Update
                this.zombies.forEach(z => z.update(dt, this));
                this.zombies = this.zombies.filter(z => !z.toBeRemoved);

                // PowerUp Update
                this.powerUps.forEach(p => p.update(dt));
                this.powerUps = this.powerUps.filter(p => !p.toBeRemoved);

                // PowerUp Collision
                this.powerUps.forEach(p => {
                    if (p.pos.dist(this.player.pos) < this.player.radius + p.radius) {
                        p.toBeRemoved = true;
                        // Effect
                        if (p.type === 'nuke') {
                            this.zombies.forEach(z => {
                                z.health = 0;
                                z.toBeRemoved = true;
                            });
                            this.score += 400;
                        } else if (p.type === 'insta') {
                            this.instaKill = true;
                            this.instaKillTimer = 30;
                        } else if (p.type === 'double') {
                            this.doublePoints = true;
                            this.doublePointsTimer = 30;
                        } else if (p.type === 'ammo') {
                            this.player.inventory.forEach(w => w.reserve = w.reserveMax);
                        }
                    }
                });

                // Camera Follow
                this.camera.x = this.player.pos.x - this.canvas.width / 2;
                this.camera.y = this.player.pos.y - this.canvas.height / 2;

                // Update UI
                document.getElementById('score-display').innerText = `Points: ${this.score}`;
                document.getElementById('round-display').innerText = this.toRoman(this.round);
                const weapon = this.player.weapon;
                document.getElementById('weapon-name').innerText = weapon.name;
                document.getElementById('ammo-count').innerText = `${weapon.currentMag} / ${weapon.reserve}`;
                if (weapon.reloading) document.getElementById('ammo-count').innerText = "RELOADING...";

                // Interaction Prompt
                const interactables = [...this.map.windows, ...this.map.doors, ...this.map.wallBuys, this.map.mysteryBox];
                let closest = null;
                let minD = Infinity;
                interactables.forEach(obj => {
                    const d = this.player.pos.dist(obj.getCenter());
                    if (d < CONSTANTS.INTERACT_DISTANCE && d < minD) {
                        minD = d;
                        closest = obj;
                    }
                });

                const promptEl = document.getElementById('interaction-prompt');
                if (closest && minD < CONSTANTS.INTERACT_DISTANCE) {
                    promptEl.style.display = 'block';
                    if (closest instanceof Window) promptEl.innerText = "Press F to Repair";
                    else if (closest instanceof Door && !closest.open) promptEl.innerText = `Press F to Open [Cost: ${closest.cost}]`;
                    else if (closest instanceof WallBuy) {
                        const existing = this.player.inventory.find(w => w.name === closest.weaponName);
                        if (existing) promptEl.innerText = `Press F to Buy Ammo [Cost: ${Math.floor(closest.cost/2)}]`;
                        else promptEl.innerText = `Press F to Buy ${closest.weaponName} [Cost: ${closest.cost}]`;
                    }
                    else if (closest instanceof MysteryBox) {
                        if (closest.state === 'idle') promptEl.innerText = `Press F for Mystery Box [Cost: ${closest.cost}]`;
                        else if (closest.state === 'open') promptEl.innerText = `Press F to Take ${WEAPONS_DATA[closest.selectedWeaponKey].name}`;
                    }
                } else {
                    promptEl.style.display = 'none';
                }

                this.input.resetJustPressed();
            }

            draw() {
                this.ctx.fillStyle = '#222';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                this.ctx.save();
                this.ctx.translate(-this.camera.x, -this.camera.y);

                this.map.draw(this.ctx);

                this.powerUps.forEach(p => p.draw(this.ctx));
                this.bullets.forEach(b => b.draw(this.ctx));
                this.zombies.forEach(z => z.draw(this.ctx));
                this.player.draw(this.ctx); // Draw player on top

                this.ctx.restore();

                // HUD Layer (Proximity Indicators)
                this.drawProximityIndicators(this.ctx);
            }

            drawProximityIndicators(ctx) {
                const cx = this.canvas.width / 2;
                const cy = this.canvas.height / 2;
                const center = new Vector2(cx, cy);

                this.zombies.forEach(z => {
                    // Zombie screen pos
                    const screenPos = z.pos.sub(this.camera);

                    // Check if off-screen
                    if (screenPos.x < 0 || screenPos.x > this.canvas.width ||
                        screenPos.y < 0 || screenPos.y > this.canvas.height) {

                        const dir = screenPos.sub(center).normalize();
                        // Push indicator to edge (minus padding)
                        const padding = 30;
                        let tx = 0, ty = 0;

                        // Calculate intersection with screen edges
                        // Slope m = dy/dx
                        if (dir.x !== 0) {
                             const m = dir.y / dir.x;
                             // Try Right/Left edges
                             if (dir.x > 0) tx = this.canvas.width - padding;
                             else tx = padding;
                             ty = cy + m * (tx - cx);

                             // If y is out of bounds, try Top/Bottom
                             if (ty < padding || ty > this.canvas.height - padding) {
                                 if (dir.y > 0) ty = this.canvas.height - padding;
                                 else ty = padding;
                                 tx = cx + (ty - cy) / m;
                             }
                        } else {
                            // Vertical
                            tx = cx;
                            ty = dir.y > 0 ? this.canvas.height - padding : padding;
                        }

                        // Draw Arrow
                        ctx.save();
                        ctx.translate(tx, ty);
                        ctx.rotate(Math.atan2(dir.y, dir.x));
                        ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';
                        ctx.beginPath();
                        ctx.moveTo(10, 0);
                        ctx.lineTo(-10, 10);
                        ctx.lineTo(-10, -10);
                        ctx.fill();
                        ctx.restore();
                    }
                });
            }

            loop(timestamp) {
                const dt = (timestamp - this.lastTime) / 1000;
                this.lastTime = timestamp;

                if (dt < 0.1) {
                    this.update(dt);
                    this.draw();
                }

                this.requestLoop();
            }

            requestLoop() {
                requestAnimationFrame((t) => this.loop(t));
            }
        }

        window.onload = () => {
            const game = new Game();
        };

    </script>
</body>
</html>
