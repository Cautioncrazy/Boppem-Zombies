<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Web of the Dead: Nacht Der Untoten (FPS V6)</title>
    <script>
        console.log("GAME VERSION: FPS V7 (Crash Fix) LOADED");
        // Error Handler
        window.onerror = function(msg, url, line, col, error) {
            const div = document.createElement('div');
            div.style.position = 'absolute';
            div.style.top = '0';
            div.style.left = '0';
            div.style.width = '100%';
            div.style.background = 'rgba(255,0,0,0.8)';
            div.style.color = '#fff';
            div.style.padding = '10px';
            div.innerText = `ERROR: ${msg}\nLine: ${line}`;
            document.body.appendChild(div);
        };
        // Force unregister any potential service workers
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.getRegistrations().then(function(registrations) {
                for(let registration of registrations) {
                    registration.unregister();
                }
            });
        }
    </script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; color: #fff; font-family: Courier, monospace; touch-action: none; user-select: none; }
        canvas { display: block; width: 100%; height: 100%; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        .hud { position: absolute; text-shadow: 2px 2px 0 #000; font-weight: bold; }
        #score { top: 20px; left: 20px; font-size: 24px; color: #ffd700; }
        #round { bottom: 20px; left: 20px; font-size: 36px; color: #bd0000; }
        #ammo { bottom: 20px; right: 20px; text-align: right; font-size: 24px; }
        #prompt { top: 60%; left: 50%; transform: translate(-50%, -50%); font-size: 20px; background: rgba(0,0,0,0.7); padding: 10px; display: none; }
        #damage { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: red; opacity: 0; transition: opacity 0.2s; pointer-events: none; }
        #game-over { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(50,0,0,0.9); display: none; flex-direction: column; justify-content: center; align-items: center; pointer-events: auto; }
        #game-over h1 { color: #bd0000; font-size: 60px; margin: 0; }
        #game-over button { margin-top: 20px; padding: 15px 30px; font-size: 24px; cursor: pointer; background: #444; color: #fff; border: 2px solid #fff; }
        #fps-mode { position: absolute; top: 20px; right: 20px; color: #0f0; font-size: 16px; opacity: 0.7; }

        /* Pause Menu */
        #pause-menu { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); display: none; flex-direction: column; align-items: center; justify-content: center; pointer-events: auto; z-index: 100; }
        #pause-menu h1 { color: #fff; font-size: 40px; margin-bottom: 20px; }
        .menu-section { width: 80%; max-width: 400px; margin-bottom: 20px; border: 1px solid #444; padding: 10px; background: rgba(50,50,50,0.5); }
        .menu-section h3 { margin-top: 0; border-bottom: 1px solid #666; padding-bottom: 5px; }
        #advanced-menu { display: none; padding-top: 10px; border-top: 1px solid #666; margin-top: 10px; }
        #toggle-adv-btn { background: none; border: none; color: #ffd700; text-decoration: underline; cursor: pointer; font-family: inherit; font-size: 16px; width: 100%; text-align: center; }
        .setting-row { display: flex; justify-content: space-between; align-items: center; margin: 10px 0; }
        .setting-row label { font-size: 18px; }
        .setting-row input[type="range"] { width: 50%; }
        .setting-row input[type="checkbox"] { width: 20px; height: 20px; }
        .key-bind { background: #333; padding: 5px 10px; border: 1px solid #666; cursor: pointer; min-width: 80px; text-align: center; }
        .key-bind:hover { background: #555; }
        .key-bind.listening { background: #d00; color: white; border-color: red; }
        button.menu-btn { padding: 10px 20px; font-size: 20px; cursor: pointer; background: #444; color: #fff; border: 2px solid #fff; margin-top: 10px; }
        button.menu-btn:hover { background: #666; }

        /* Mobile Controls */
        .touch-zone { position: absolute; bottom: 20px; width: 150px; height: 150px; border: 2px solid rgba(255,255,255,0.3); border-radius: 50%; pointer-events: auto; display: none; }
        .touch-knob { width: 50px; height: 50px; background: rgba(255,255,255,0.5); border-radius: 50%; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); pointer-events: none; }
        #stick-left { left: 20px; }
        #stick-right { right: 20px; }
        #btn-action { position: absolute; bottom: 180px; right: 40px; width: 80px; height: 80px; background: rgba(0,255,0,0.3); border: 2px solid #0f0; border-radius: 50%; display: none; justify-content: center; align-items: center; font-size: 30px; pointer-events: auto; }
        #btn-reload { position: absolute; bottom: 180px; right: 140px; width: 60px; height: 60px; background: rgba(255,255,0,0.3); border: 2px solid #ff0; border-radius: 50%; display: none; justify-content: center; align-items: center; font-size: 20px; pointer-events: auto; }
        #btn-fire { position: absolute; bottom: 80px; right: 180px; width: 80px; height: 80px; background: rgba(255,0,0,0.3); border: 2px solid #f00; border-radius: 50%; display: none; justify-content: center; align-items: center; font-size: 20px; pointer-events: auto; }

        @media (hover: none) and (pointer: coarse) {
            .touch-zone, #btn-action, #btn-reload, #btn-fire { display: flex; }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="ui-layer">
        <div id="damage"></div>
        <div id="fps-mode">FPS MODE V7</div>
        <div id="score" class="hud">Points: 500</div>
        <div id="round" class="hud">I</div>
        <div id="ammo" class="hud">M1911<br>8 / 32</div>
        <div id="prompt" class="hud">Press F to Interact</div>

        <!-- Pause Menu -->
        <div id="pause-menu">
            <h1>PAUSED</h1>

            <div class="menu-section">
                <h3>Controls</h3>
                <div class="setting-row">
                    <label>Sensitivity (Mouse)</label>
                    <input type="range" id="sens-slider" min="1" max="10" step="0.5" value="3.0">
                    <span id="sens-val">3.0</span>
                </div>
                <button id="toggle-adv-btn" onclick="document.getElementById('advanced-menu').style.display = (document.getElementById('advanced-menu').style.display==='block'?'none':'block')">Advanced Settings ‚ñº</button>
                <div id="advanced-menu">
                    <div class="setting-row">
                        <label>Vert. Sens (Y)</label>
                        <input type="range" id="sens-y-slider" min="1" max="10" step="0.5" value="2.0">
                        <span id="sens-y-val">2.0</span>
                    </div>
                    <div class="setting-row">
                        <label>Horiz. Sens (X)</label>
                        <input type="range" id="sens-x-slider" min="1" max="10" step="0.5" value="3.0">
                        <span id="sens-x-val">3.0</span>
                    </div>
                    <div class="setting-row">
                        <label>ADS Multiplier</label>
                        <input type="range" id="ads-mult-slider" min="0.1" max="1.0" step="0.1" value="0.5">
                        <span id="ads-mult-val">0.5x</span>
                    </div>
                    <div class="setting-row">
                        <label>Deadzone</label>
                        <input type="range" id="deadzone-slider" min="0.0" max="0.5" step="0.05" value="0.1">
                        <span id="deadzone-val">0.1</span>
                    </div>
                    <div class="setting-row">
                        <label>Vibration (Haptics)</label>
                        <input type="range" id="vibration-slider" min="0.0" max="1.0" step="0.1" value="1.0">
                        <span id="vibration-val">100%</span>
                    </div>
                </div>

                <div class="setting-row">
                    <label>Invert Y</label>
                    <input type="checkbox" id="invert-y">
                </div>
                <div class="setting-row">
                    <label>Invert X</label>
                    <input type="checkbox" id="invert-x">
                </div>
                <div class="setting-row">
                    <label>Toggle ADS</label>
                    <input type="checkbox" id="toggle-ads">
                </div>
            </div>

            <div class="menu-section">
                <h3>Key Bindings (Click to Remap)</h3>
                <div class="setting-row">
                    <label>Forward</label>
                    <div class="key-bind" data-action="forward">W</div>
                </div>
                <div class="setting-row">
                    <label>Backward</label>
                    <div class="key-bind" data-action="backward">S</div>
                </div>
                <div class="setting-row">
                    <label>Left</label>
                    <div class="key-bind" data-action="left">A</div>
                </div>
                <div class="setting-row">
                    <label>Right</label>
                    <div class="key-bind" data-action="right">D</div>
                </div>
                <div class="setting-row">
                    <label>Interact</label>
                    <div class="key-bind" data-action="interact">F</div>
                </div>
                <div class="setting-row">
                    <label>Reload</label>
                    <div class="key-bind" data-action="reload">R</div>
                </div>
            </div>

            <button class="menu-btn" id="resume-btn">RESUME</button>
        </div>

        <div id="stick-left" class="touch-zone"><div class="touch-knob"></div></div>
        <div id="stick-right" class="touch-zone"><div class="touch-knob"></div></div>
        <div id="btn-action">üñêÔ∏è</div>
        <div id="btn-reload">‚Üª</div>
        <div id="btn-fire">üî•</div>

        <div id="game-over">
            <h1>GAME OVER</h1>
            <h2 id="final-score">Score: 0</h2>
            <h3 id="final-round">Round: 1</h3>
            <button onclick="location.reload()">TRY AGAIN</button>
        </div>
    </div>

    <script>
        // --- CONSTANTS ---
        const C = {
            FOV: Math.PI / 3,
            FOV_ADS: Math.PI / 4.5,
            RES: 2, // 1=High, 2=Med, 4=Low
            MAX_DEPTH: 20,
            MOVE_SPEED: 3.0,
            MOVE_SPEED_ADS: 1.5,
            ROT_SPEED_BASE: 2.0, // Base speed multiplier
            PLAYER_RADIUS: 0.3,
            MAP_SIZE: 20
        };

        // --- MAP & ASSETS ---
        const MAP = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [5,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1], // Wallbuy at (1, 2) now ID 5
            [1,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,2,1,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,1],
            [1,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1],
            [1,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1],
            [1,0,1,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,1],
            [1,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1],
            [1,0,1,1,1,3,1,1,1,2,1,1,1,1,0,0,0,0,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];
        for(let i=MAP.length; i<20; i++) MAP.push(new Array(20).fill(1));

        const OBJECTS = [
            { type: 'door', x: 6, y: 3, cost: 1000, targetZone: 1, open: false },
            { type: 'door', x: 5, y: 10, cost: 1000, targetZone: 2, open: false },
            { type: 'window', x: 1, y: 5, boards: 6, maxBoards: 6, lastDamage: 0 },
            { type: 'window', x: 13, y: 8, boards: 6, maxBoards: 6, lastDamage: 0 },
            { type: 'window', x: 9, y: 10, boards: 6, maxBoards: 6, lastDamage: 0 },
            { type: 'wallbuy', x: 1, y: 2, weapon: 'Kar98k', cost: 200 } // Adjusted to match wall ID 5
        ];

        const WEAPONS = {
            'M1911': { name: 'M1911', damage: 20, fireRate: 0.4, magSize: 8, reserveMax: 32, reloadTime: 1.5, spread: 0.05, color: '#555', type: 'pistol' },
            'Kar98k': { name: 'Kar98k', damage: 100, fireRate: 1.0, magSize: 5, reserveMax: 50, reloadTime: 2.5, spread: 0.01, color: '#8B4513', type: 'rifle' },
            'RayGun': { name: 'Ray Gun', damage: 1000, fireRate: 0.3, magSize: 20, reserveMax: 160, reloadTime: 3.0, spread: 0.0, color: '#0f0', type: 'scifi' }
        };

        // --- AUDIO ---
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const AUDIO = new AudioContext();

        function playSound(type) {
            if (AUDIO.state === 'suspended') AUDIO.resume();
            const osc = AUDIO.createOscillator();
            const gain = AUDIO.createGain();
            osc.connect(gain);
            gain.connect(AUDIO.destination);

            const now = AUDIO.currentTime;

            if (type === 'shoot') {
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.exponentialRampToValueAtTime(0.01, now + 0.1);
                gain.gain.setValueAtTime(0.3, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            } else if (type === 'hit') {
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(800, now);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
                osc.start(now);
                osc.stop(now + 0.05);
            } else if (type === 'reload') {
                osc.frequency.setValueAtTime(400, now);
                osc.frequency.linearRampToValueAtTime(600, now + 0.2);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0.01, now + 0.2);
                osc.start(now);
                osc.stop(now + 0.2);
            } else if (type === 'empty') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(800, now);
                gain.gain.setValueAtTime(0.05, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
                osc.start(now);
                osc.stop(now + 0.05);
            }
        }

        // --- SETTINGS ---
        const SETTINGS = {
            sensitivity: 3.0, // Base/Mouse sensitivity
            sensX: 3.0,       // Controller/Advanced Horizontal
            sensY: 2.0,       // Controller/Advanced Vertical
            adsMult: 0.5,     // ADS Multiplier
            deadzone: 0.1,    // Stick Deadzone
            vibrationIntensity: 1.0, // Haptic Strength (0.0 - 1.0)
            invertY: false,
            invertX: false,
            toggleADS: false,
            keys: {
                forward: 'KeyW',
                backward: 'KeyS',
                left: 'KeyA',
                right: 'KeyD',
                interact: 'KeyF',
                reload: 'KeyR'
            }
        };

        // --- TEXTURE GENERATOR ---
        const TextureGen = {
            createCanvas(w, h) {
                const c = document.createElement('canvas');
                c.width = w; c.height = h;
                return { c, ctx: c.getContext('2d') };
            },
            noise(ctx, w, h, density=0.1) {
                const id = ctx.getImageData(0,0,w,h);
                const d = id.data;
                for(let i=0; i<d.length; i+=4) {
                    if(Math.random()<density) {
                        const v = Math.random()*50;
                        d[i]-=v; d[i+1]-=v; d[i+2]-=v;
                    }
                }
                ctx.putImageData(id,0,0);
            },
            bricks(color, mortar) {
                const s = 64; // Size
                const {c, ctx} = this.createCanvas(s, s);
                ctx.fillStyle = color;
                ctx.fillRect(0,0,s,s);
                this.noise(ctx, s, s, 0.2);

                ctx.fillStyle = mortar;
                // Horizontal lines
                ctx.fillRect(0, 0, s, 2);
                ctx.fillRect(0, 32, s, 2);
                // Vertical (staggered)
                ctx.fillRect(32, 2, 2, 30);
                ctx.fillRect(0, 34, 2, 30);
                return c;
            },
            metal() {
                const s = 64;
                const {c, ctx} = this.createCanvas(s, s);
                const g = ctx.createLinearGradient(0,0,s,s);
                g.addColorStop(0, '#888');
                g.addColorStop(0.5, '#eee');
                g.addColorStop(1, '#888');
                ctx.fillStyle = g;
                ctx.fillRect(0,0,s,s);
                this.noise(ctx, s, s, 0.05);
                ctx.strokeStyle = '#555';
                ctx.strokeRect(0,0,s,s);
                return c;
            },
            wood() {
                const s = 64;
                const {c, ctx} = this.createCanvas(s, s);
                ctx.fillStyle = '#6F4E37';
                ctx.fillRect(0,0,s,s);
                // Grain
                ctx.strokeStyle = '#5D4037';
                for(let i=0; i<10; i++) {
                    ctx.beginPath();
                    ctx.moveTo(i*6 + Math.random()*5, 0);
                    ctx.lineTo(i*6 + Math.random()*5, s);
                    ctx.stroke();
                }
                return c;
            },
            zombie() {
                const s = 64;
                const {c, ctx} = this.createCanvas(s, s);
                // Skin
                ctx.fillStyle = '#2E8B57'; // SeaGreen
                ctx.fillRect(16, 10, 32, 40); // Body
                ctx.beginPath(); ctx.arc(32, 16, 14, 0, Math.PI*2); ctx.fill(); // Head

                // Details
                ctx.fillStyle = '#f00'; // Eyes
                ctx.fillRect(24, 12, 4, 4);
                ctx.fillRect(36, 12, 4, 4);

                // Blood/Gore
                ctx.fillStyle = '#800';
                ctx.beginPath();
                ctx.moveTo(32, 24); ctx.lineTo(28, 30); ctx.lineTo(36, 30);
                ctx.fill(); // Mouth

                // Clothes (Rags)
                ctx.fillStyle = '#555';
                ctx.fillRect(16, 30, 32, 20);

                return c;
            },
            wallbuy() {
                const s = 64;
                const {c, ctx} = this.createCanvas(s, s);
                // Base Wall
                ctx.fillStyle = '#666';
                ctx.fillRect(0,0,s,s);
                this.noise(ctx, s, s, 0.2);
                ctx.fillStyle = '#333';
                ctx.fillRect(0, 0, s, 2); ctx.fillRect(0, 32, s, 2);
                ctx.fillRect(32, 2, 2, 30); ctx.fillRect(0, 34, 2, 30);

                // Chalk Outline
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.lineJoin = 'round';
                ctx.beginPath();
                // Rough gun shape
                ctx.moveTo(10, 20); ctx.lineTo(50, 20); // Barrel
                ctx.lineTo(50, 35); ctx.lineTo(40, 35); // Grip Top
                ctx.lineTo(35, 45); ctx.lineTo(25, 45); // Grip Bottom
                ctx.lineTo(30, 35); ctx.lineTo(10, 35); // Trigger Guard / Body
                ctx.closePath();
                ctx.stroke();

                ctx.font = '10px monospace';
                ctx.fillStyle = '#fff';
                ctx.fillText('BUY', 20, 55);

                return c;
            }
        };

        const TEXTURES = {
            wall: TextureGen.bricks('#666', '#333'),
            door: TextureGen.metal(),
            window: TextureGen.wood(),
            zombie: TextureGen.zombie(),
            wallbuy: TextureGen.wallbuy()
        };

        // --- GAME ---
        class Game {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d', { alpha: false });
                this.resize();

                this.player = {
                    x: 3.5, y: 2.5, z: 0, dir: 0, pitch: 0, // z for jump
                    health: 100, maxHealth: 100,
                    lastDamage: 0,
                    score: 500,
                    inventory: [ { ...WEAPONS['M1911'], currentMag: 8, reserve: 32 } ],
                    currentWeapon: 0,
                    lastFire: 0, reloading: false,
                    vz: 0, // Vertical Velocity
                    isCrouched: false, isSprinting: false,
                    grenades: 2, maxGrenades: 4
                };

                this.zombies = [];
                this.bullets = [];
                this.grenadeObjs = [];
                this.round = 1;
                this.spawnTimer = 0;
                this.zombiesToSpawn = 5;
                this.lastTime = 0;
                this.running = true;
                this.paused = false;

                this.input = new InputHandler(this);
                this.setupUI();

                // Bindings
                this.loop = this.loop.bind(this);
                requestAnimationFrame(this.loop);
            }

            setupUI() {
                // Settings UI Handlers
                const slider = document.getElementById('sens-slider');
                const valDisplay = document.getElementById('sens-val');
                slider.addEventListener('input', (e) => {
                    SETTINGS.sensitivity = parseFloat(e.target.value);
                    valDisplay.innerText = SETTINGS.sensitivity.toFixed(1);
                });

                document.getElementById('sens-y-slider').addEventListener('input', (e) => { SETTINGS.sensY = parseFloat(e.target.value); document.getElementById('sens-y-val').innerText = SETTINGS.sensY.toFixed(1); });
                document.getElementById('sens-x-slider').addEventListener('input', (e) => { SETTINGS.sensX = parseFloat(e.target.value); document.getElementById('sens-x-val').innerText = SETTINGS.sensX.toFixed(1); });
                document.getElementById('ads-mult-slider').addEventListener('input', (e) => { SETTINGS.adsMult = parseFloat(e.target.value); document.getElementById('ads-mult-val').innerText = SETTINGS.adsMult.toFixed(1) + 'x'; });
                document.getElementById('deadzone-slider').addEventListener('input', (e) => { SETTINGS.deadzone = parseFloat(e.target.value); document.getElementById('deadzone-val').innerText = SETTINGS.deadzone.toFixed(2); });
                document.getElementById('vibration-slider').addEventListener('input', (e) => { SETTINGS.vibrationIntensity = parseFloat(e.target.value); document.getElementById('vibration-val').innerText = Math.round(SETTINGS.vibrationIntensity * 100) + '%'; });

                document.getElementById('invert-y').addEventListener('change', e => SETTINGS.invertY = e.target.checked);
                document.getElementById('invert-x').addEventListener('change', e => SETTINGS.invertX = e.target.checked);
                document.getElementById('toggle-ads').addEventListener('change', e => SETTINGS.toggleADS = e.target.checked);
                document.getElementById('resume-btn').addEventListener('click', () => this.togglePause(false));

                // Key Rebinding
                document.querySelectorAll('.key-bind').forEach(el => {
                    el.addEventListener('click', () => {
                        el.classList.add('listening');
                        el.innerText = 'Press Key...';

                        const handler = (e) => {
                            e.preventDefault();
                            const action = el.dataset.action;
                            SETTINGS.keys[action] = e.code;
                            el.innerText = e.code.replace('Key', '');
                            el.classList.remove('listening');
                            window.removeEventListener('keydown', handler);

                            // Re-init input keys
                            this.input.keys[e.code] = false; // Reset state
                        };
                        window.addEventListener('keydown', handler, { once: true });
                    });
                });
            }

            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.ctx.imageSmoothingEnabled = false;
            }

            togglePause(state) {
                this.paused = state;
                const menu = document.getElementById('pause-menu');
                if (this.paused) {
                    menu.style.display = 'flex';
                    document.exitPointerLock();
                    this.lastTime = 0; // Reset delta time
                } else {
                    menu.style.display = 'none';
                    this.canvas.requestPointerLock();
                    this.lastTime = performance.now();
                }
            }

            loop(timestamp) {
                if (!this.running) return;

                if (this.lastTime === 0) this.lastTime = timestamp; // First frame fix
                const dt = (timestamp - this.lastTime) / 1000;

                if (!this.paused) {
                    this.update(Math.min(dt, 0.1));
                    this.render();
                }

                this.lastTime = timestamp;
                requestAnimationFrame(this.loop);
            }

            update(dt) {
                if (this.player.health <= 0) return this.gameOver();

                // Clear HitMarkers
                if (this.hitMarkerTime && Date.now() - this.hitMarkerTime > 100) this.hitMarkerTime = 0;

                // Health Regen
                if (this.player.health < this.player.maxHealth && Date.now() - this.player.lastDamage > 5000) {
                    this.player.health += 20 * dt;
                    if (this.player.health > this.player.maxHealth) this.player.health = this.player.maxHealth;
                    this.updateHUD();
                }

                // Input State
                this.input.pollGamepads();
                this.player.isAiming = this.input.isAiming();

                // Player Movement
                const move = this.input.getMove();
                const rot = this.input.getLook();

                // Apply Sensitivity
                this.player.dir += rot.x * C.ROT_SPEED_BASE * SETTINGS.sensitivity * dt;
                this.player.dir = (this.player.dir % (2 * Math.PI));

                // Apply Pitch
                this.player.pitch += rot.y * SETTINGS.sensitivity * 200 * dt; // Scale pitch speed
                // Clamp Pitch
                const maxPitch = 200; // Screen pixels offset approximately
                if (this.player.pitch > maxPitch) this.player.pitch = maxPitch;
                if (this.player.pitch < -maxPitch) this.player.pitch = -maxPitch;

                let baseSpeed = C.MOVE_SPEED;
                if (this.player.isAiming) baseSpeed = C.MOVE_SPEED_ADS;
                if (this.player.isSprinting) baseSpeed *= 1.5;
                if (this.player.isCrouched) baseSpeed *= 0.5;
                const speed = baseSpeed * dt;
                const cos = Math.cos(this.player.dir);
                const sin = Math.sin(this.player.dir);

                // Move Vector relative to direction
                let dx = (cos * move.y - sin * move.x) * speed;
                let dy = (sin * move.y + cos * move.x) * speed;

                const checkWalkable = (x, y) => {
                    if (y < 0 || y >= MAP.length || x < 0 || x >= MAP[0].length) return false;
                    const id = MAP[Math.floor(y)][Math.floor(x)];
                    return id === 0 || id === 4; // 0=Empty, 4=Open Door
                };

                // Collision margin
                const margin = 0.3;
                if (checkWalkable(this.player.x + dx + (dx>0?margin:-margin), this.player.y)) this.player.x += dx;
                if (checkWalkable(this.player.x, this.player.y + dy + (dy>0?margin:-margin))) this.player.y += dy;

                // Input Actions
                if (this.input.isAction('reload')) this.reload();
                if (this.input.isFiring()) this.fire(Date.now());
                if (this.input.isAction('interact') || this.input.buttons.action) this.interact();

                // Pause Toggle (Debounced slightly handled in InputHandler)

                // Zombie Spawning
                if (this.zombiesToSpawn > 0) {
                    this.spawnTimer += dt;
                    if (this.spawnTimer > 3.0) {
                        this.spawnZombie();
                        this.spawnTimer = 0;
                        this.zombiesToSpawn--;
                    }
                } else if (this.zombies.length === 0) {
                    this.round++;
                    this.zombiesToSpawn = Math.floor(5 * Math.pow(1.2, this.round-1));
                    document.getElementById('round').innerText = this.toRoman(this.round);
                }

                // Zombie Logic
                this.zombies.forEach(z => {
                    const dist = Math.sqrt((this.player.x - z.x)**2 + (this.player.y - z.y)**2);
                    if (dist > 0.5) {
                        const angle = Math.atan2(this.player.y - z.y, this.player.x - z.x);
                        let zdx = Math.cos(angle) * dt * (0.8 + this.round * 0.05);
                        let zdy = Math.sin(angle) * dt * (0.8 + this.round * 0.05);

                        if (MAP[Math.floor(z.y)][Math.floor(z.x + zdx * 1.5)] <= 0) z.x += zdx; // Allow walking through empty(0)
                        if (MAP[Math.floor(z.y + zdy * 1.5)][Math.floor(z.x)] <= 0) z.y += zdy;
                    } else {
                        if (Date.now() - z.lastAttack > 1000) {
                            this.player.health -= 20;
                            this.player.lastDamage = Date.now();
                            z.lastAttack = Date.now();
                            this.updateHUD();
                        }
                    }
                });
                this.zombies = this.zombies.filter(z => z.health > 0);

                // Physics (Jump/Grenades)
                this.updatePhysics(dt);

                // Check Interactable Prompt
                this.checkInteraction();
            }

            updatePhysics(dt) {
                // Jump/Gravity
                if (this.player.z > 0 || this.player.vz !== 0) {
                    this.player.vz -= 20 * dt; // Gravity
                    this.player.z += this.player.vz * dt;
                    if (this.player.z <= 0) {
                        this.player.z = 0;
                        this.player.vz = 0;
                    }
                }

                // Grenades (Simple)
                this.grenadeObjs.forEach(g => {
                    g.vz -= 10 * dt;
                    g.x += g.vx * dt;
                    g.y += g.vy * dt;
                    g.z += g.vz * dt;

                    if (g.z < 0) { // Bounce
                        g.z = 0;
                        g.vz = -g.vz * 0.5;
                        g.vx *= 0.7;
                        g.vy *= 0.7;
                    }

                    g.timer -= dt;
                    if (g.timer <= 0 && !g.exploded) {
                        this.explodeGrenade(g);
                    }
                });
                this.grenadeObjs = this.grenadeObjs.filter(g => !g.exploded);
            }

            explodeGrenade(g) {
                g.exploded = true;
                playSound('shoot'); // Placeholder boom
                this.input.haptic(200, 1.0, 1.0);
                // Area Damage
                this.zombies.forEach(z => {
                    const dist = Math.sqrt((z.x - g.x)**2 + (z.y - g.y)**2);
                    if (dist < 5.0) {
                         z.health -= 200 / (dist + 0.5);
                    }
                });
            }

            jump() {
                if (this.player.z === 0) {
                    this.player.vz = 6;
                }
            }

            toggleCrouch() {
                this.player.isCrouched = !this.player.isCrouched;
            }

            toggleSprint() {
                this.player.isSprinting = !this.player.isSprinting;
            }

            switchWeapon() {
                if (this.player.inventory.length > 1) {
                    this.player.currentWeapon = (this.player.currentWeapon + 1) % this.player.inventory.length;
                    this.updateHUD();
                }
            }

            throwGrenade() {
                if (this.player.grenades > 0) {
                    this.player.grenades--;
                    const speed = 10;
                    this.grenadeObjs.push({
                        x: this.player.x, y: this.player.y, z: 0.5,
                        vx: Math.cos(this.player.dir) * speed,
                        vy: Math.sin(this.player.dir) * speed,
                        vz: 3,
                        timer: 3.0, exploded: false
                    });
                    this.updateHUD();
                }
            }

            melee() {
                // Short range hit
                this.input.haptic(100, 0.5, 0.5);
                let hit = false;
                this.zombies.forEach(z => {
                    const dist = Math.sqrt((this.player.x - z.x)**2 + (this.player.y - z.y)**2);
                    if (dist < 1.5) {
                        // Check angle
                        const angleToZ = Math.atan2(z.y - this.player.y, z.x - this.player.x);
                        let angleDiff = Math.abs(angleToZ - this.player.dir);
                        if (angleDiff < 1.0) {
                            z.health -= 150;
                            hit = true;
                        }
                    }
                });
                if(hit) playSound('hit');
            }

            spawnZombie() {
                const windows = OBJECTS.filter(o => o.type === 'window');
                if (windows.length > 0) {
                    const w = windows[Math.floor(Math.random() * windows.length)];
                    this.zombies.push({ x: w.x, y: w.y, health: 100 * Math.pow(1.1, this.round-1), lastAttack: 0 });
                }
            }

            fire(time) {
                const w = this.player.inventory[this.player.currentWeapon];

                // Auto-Reload Trigger
                if (w.currentMag === 0 && w.reserve > 0 && !this.player.reloading) {
                    this.reload();
                    return;
                }

                if (time - this.player.lastFire > w.fireRate * 1000 && w.currentMag > 0 && !this.player.reloading) {
                    w.currentMag--;
                    this.player.lastFire = time;
                    playSound('shoot');
                    this.input.haptic(50);
                    this.updateHUD();

                    // Hitscan Logic
                    let closestDist = Infinity;
                    let hitZombie = null;

                    this.zombies.forEach(z => {
                        const angleToZ = Math.atan2(z.y - this.player.y, z.x - this.player.x);
                        let angleDiff = angleToZ - this.player.dir;

                        // Robust normalization to [-PI, PI] using trig (avoids loops)
                        angleDiff = Math.atan2(Math.sin(angleDiff), Math.cos(angleDiff));

                        if (Math.abs(angleDiff) < 0.1) { // Hit cone (TODO: Narrow this for distance)
                            const d = Math.sqrt((this.player.x - z.x)**2 + (this.player.y - z.y)**2);
                            if (d < closestDist) {
                                closestDist = d;
                                hitZombie = z;
                            }
                        }
                    });

                    if (hitZombie) {
                        // Pitch Based Damage
                        let multiplier = 1.0;
                        if (this.player.pitch > 20) multiplier = 1.5; // Head
                        else if (this.player.pitch < -20) multiplier = 0.5; // Legs

                        hitZombie.health -= w.damage * multiplier;
                        this.player.score += 10;

                        this.hitMarkerTime = Date.now();
                        playSound('hit');
                        this.input.haptic(20);

                        if (hitZombie.health <= 0) this.player.score += 60;
                        this.updateHUD();
                    }
                } else if (w.currentMag === 0 && w.reserve === 0 && time - this.player.lastFire > 500) {
                     playSound('empty');
                     this.player.lastFire = time;
                }
            }

            reload() {
                const w = this.player.inventory[this.player.currentWeapon];
                if (!this.player.reloading && w.currentMag < w.magSize && w.reserve > 0) {
                    this.player.reloading = true;
                    playSound('reload');
                    this.player.lastFire = Date.now(); // Reset animation timer anchor
                    document.getElementById('ammo').innerText = "RELOADING...";

                    // Haptic Sequence
                    if (w.type === 'pistol') {
                        // M1911: Mag Out (0.2), Mag In (0.8), Slide (1.2)
                        this.input.hapticSequence([
                            { delay: 0, duration: 50, strong: 0.2, weak: 0.5 },    // Start
                            { delay: 300, duration: 100, strong: 0.5, weak: 0.2 }, // Mag Out
                            { delay: 800, duration: 150, strong: 1.0, weak: 0.0 }, // Mag In (Slam)
                            { delay: 1200, duration: 80, strong: 0.8, weak: 0.8 }  // Slide
                        ]);
                    } else if (w.type === 'rifle') {
                        // Kar98k: Bolt Up (0.4), Back (0.8), Load (1.2), Down (1.6)
                        this.input.hapticSequence([
                            { delay: 0, duration: 50, strong: 0.3, weak: 0.3 },
                            { delay: 400, duration: 100, strong: 0.6, weak: 0.0 }, // Bolt Up
                            { delay: 800, duration: 100, strong: 0.7, weak: 0.2 }, // Bolt Back
                            { delay: 1200, duration: 100, strong: 0.5, weak: 0.5 }, // Round In
                            { delay: 1800, duration: 150, strong: 0.8, weak: 0.8 }  // Bolt Forward/Down
                        ]);
                    }

                    setTimeout(() => {
                        const needed = w.magSize - w.currentMag;
                        const taken = Math.min(needed, w.reserve);
                        w.currentMag += taken;
                        w.reserve -= taken;
                        this.player.reloading = false;
                        this.updateHUD();
                    }, w.reloadTime * 1000);
                }
            }

            interact() {
                // Check closest interactable in front
                let target = null;
                let minDist = 2.0;

                OBJECTS.forEach(obj => {
                    const d = Math.sqrt((this.player.x - obj.x)**2 + (this.player.y - obj.y)**2);
                    if (d < minDist) {
                        target = obj;
                        minDist = d;
                    }
                });

                if (target) {
                    if (target.type === 'window') {
                        if (target.boards < target.maxBoards) {
                            target.boards++;
                            this.player.score += 10;
                            this.updateHUD();
                        }
                    } else if (target.type === 'door' && !target.open) {
                        if (this.player.score >= target.cost) {
                            this.player.score -= target.cost;
                            target.open = true;
                            MAP[target.y][target.x] = 4; // Open Door ID
                            this.updateHUD();
                        }
                    } else if (target.type === 'wallbuy') {
                        if (this.player.score >= target.cost) {
                            const newWep = WEAPONS[target.weapon];
                            // Replace current or add? Simply replace for prototype
                            this.player.inventory[0] = { ...newWep, currentMag: newWep.magSize, reserve: newWep.reserveMax };
                            this.player.score -= target.cost;
                            this.updateHUD();
                        }
                    }
                }
            }

            checkInteraction() {
                let prompt = "";
                let minDist = 2.0;
                OBJECTS.forEach(obj => {
                    const d = Math.sqrt((this.player.x - obj.x)**2 + (this.player.y - obj.y)**2);
                    if (d < minDist) {
                        if (obj.type === 'window' && obj.boards < obj.maxBoards) prompt = "Repair Window";
                        if (obj.type === 'door' && !obj.open) prompt = `Open Door [${obj.cost}]`;
                        if (obj.type === 'wallbuy') prompt = `Buy ${obj.weapon} [${obj.cost}]`;
                    }
                });
                const el = document.getElementById('prompt');
                if (prompt) {
                    el.style.display = 'block';
                    el.innerText = `Press ${SETTINGS.keys.interact.replace('Key','')} to: ` + prompt;
                } else {
                    el.style.display = 'none';
                }
            }

            updateHUD() {
                const w = this.player.inventory[this.player.currentWeapon];
                document.getElementById('ammo').innerHTML = `${w.name}<br>${w.currentMag} / ${w.reserve}`;
                document.getElementById('score').innerText = `Points: ${this.player.score}`;
                document.getElementById('damage').style.opacity = (1 - this.player.health/100) * 0.8;
            }

            gameOver() {
                this.running = false;
                document.getElementById('game-over').style.display = 'flex';
                document.getElementById('final-score').innerText = 'Score: ' + this.player.score;
                document.getElementById('final-round').innerText = 'Round: ' + this.round;
                document.exitPointerLock();
            }

            toRoman(num) {
                if (num === 1) return "I";
                if (num === 2) return "II";
                if (num === 3) return "III";
                if (num === 4) return "IV";
                return num.toString();
            }

            render() {
                const w = this.canvas.width;
                const h = this.canvas.height;
                const mw = w / C.RES;

                const fov = this.player.isAiming ? C.FOV_ADS : C.FOV;
                const pitchOffset = this.player.pitch;

                // Ceiling (Solid)
                this.ctx.fillStyle = '#111';
                this.ctx.fillRect(0,0,w,h/2 + pitchOffset);

                // Floor (Gradient)
                const floorGrad = this.ctx.createLinearGradient(0, h/2 + pitchOffset, 0, h);
                floorGrad.addColorStop(0, '#000');
                floorGrad.addColorStop(0.3, '#222');
                floorGrad.addColorStop(1, '#333');
                this.ctx.fillStyle = floorGrad;
                this.ctx.fillRect(0,h/2 + pitchOffset,w,h/2 - pitchOffset);

                const zBuffer = new Array(Math.ceil(mw)).fill(0);

                // Raycast Walls
                for(let x=0; x<mw; x++) {
                    const cameraX = 2 * x / mw - 1;
                    // Adjusted for dynamic FOV
                    const planeX = Math.tan(fov/2);
                    const rayDirX = Math.cos(this.player.dir) + Math.cos(this.player.dir + Math.PI/2) * cameraX * planeX;
                    const rayDirY = Math.sin(this.player.dir) + Math.sin(this.player.dir + Math.PI/2) * cameraX * planeX;

                    let mapX = Math.floor(this.player.x);
                    let mapY = Math.floor(this.player.y);
                    let sideDistX, sideDistY, perpWallDist, side, hit=0;
                    const deltaDistX = Math.abs(1/rayDirX);
                    const deltaDistY = Math.abs(1/rayDirY);
                    const stepX = (rayDirX < 0) ? -1 : 1;
                    const stepY = (rayDirY < 0) ? -1 : 1;

                    if (rayDirX < 0) sideDistX = (this.player.x - mapX) * deltaDistX;
                    else sideDistX = (mapX + 1.0 - this.player.x) * deltaDistX;
                    if (rayDirY < 0) sideDistY = (this.player.y - mapY) * deltaDistY;
                    else sideDistY = (mapY + 1.0 - this.player.y) * deltaDistY;

                    // DDA
                    let dist = 0;
                    while (hit === 0 && dist < C.MAX_DEPTH) {
                        if (sideDistX < sideDistY) { sideDistX += deltaDistX; mapX += stepX; side = 0; }
                        else { sideDistY += deltaDistY; mapY += stepY; side = 1; }

                        if (MAP[mapY] && MAP[mapY][mapX] > 0 && MAP[mapY][mapX] !== 4) hit = MAP[mapY][mapX];
                        dist++;
                    }

                    if (side === 0) perpWallDist = (mapX - this.player.x + (1 - stepX) / 2) / rayDirX;
                    else perpWallDist = (mapY - this.player.y + (1 - stepY) / 2) / rayDirY;

                    zBuffer[x] = perpWallDist;

                    const lineHeight = Math.floor(h / perpWallDist);
                    // Apply pitch offset to drawStart + Jump/Crouch Z + bob
                    const camH = h/2 + (this.player.isCrouched ? -50 : 0) + (this.player.z * 50);
                    const drawStart = -lineHeight / 2 + camH + pitchOffset;

                    // Texture Mapping
                    let texX;
                    if (side === 0) texX = this.player.y + perpWallDist * rayDirY;
                    else            texX = this.player.x + perpWallDist * rayDirX;
                    texX -= Math.floor(texX);

                    let tex = TEXTURES.wall;
                    if (hit === 2) tex = TEXTURES.door;
                    if (hit === 3) tex = TEXTURES.window;
                    if (hit === 4) tex = TEXTURES.door; // Open Door

                    const ts = 64; // Texture size
                    let tx = Math.floor(texX * ts);
                    if(side == 0 && rayDirX > 0) tx = ts - tx - 1;
                    if(side == 1 && rayDirY < 0) tx = ts - tx - 1;

                    // Draw Texture Strip
                    this.ctx.drawImage(tex,
                        tx, 0, 1, ts, // Source: 1 pixel wide strip
                        x * C.RES, drawStart, C.RES, lineHeight // Dest: Scaled to screen height
                    );

                    // Distance/Side Shading (Black Overlay)
                    this.ctx.fillStyle = '#000';
                    let alpha = perpWallDist / C.MAX_DEPTH; // Distance fade
                    if (side === 1) alpha += 0.2; // Side shading
                    this.ctx.globalAlpha = Math.min(0.8, alpha);
                    this.ctx.fillRect(x * C.RES, drawStart, C.RES, lineHeight);
                    this.ctx.globalAlpha = 1.0;

                    // Edge Outline (Top/Bottom)
                    this.ctx.fillStyle = '#000';
                    this.ctx.fillRect(x * C.RES, drawStart - 1, C.RES, 2);
                    this.ctx.fillRect(x * C.RES, drawStart + lineHeight - 1, C.RES, 2);
                }

                // Sprite Casting (Zombies)
                this.zombies.forEach(z => {
                    const dx = z.x - this.player.x;
                    const dy = z.y - this.player.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);

                    const spriteAngle = Math.atan2(dy, dx) - this.player.dir;
                    let diff = Math.atan2(Math.sin(spriteAngle), Math.cos(spriteAngle));

                    if (Math.abs(diff) < fov / 1.5) {
                        const screenX = (0.5 * (diff / (fov / 2)) + 0.5) * w;
                        const spriteH = h / dist;
                        const spriteW = spriteH * 0.6;
                        // Apply pitch offset to spriteTop
                        const spriteTop = (h - spriteH) / 2 + pitchOffset;

                        const zBufIdx = Math.floor(screenX / C.RES);
                        if (zBufIdx >= 0 && zBufIdx < mw && dist < zBuffer[zBufIdx]) {
                            this.ctx.drawImage(TEXTURES.zombie, screenX - spriteW/2, spriteTop, spriteW, spriteH);
                        }
                    }
                });

                // Vignette (Flashlight)
                const rad = this.ctx.createRadialGradient(w/2, h/2, h*0.2, w/2, h/2, h*0.8);
                rad.addColorStop(0, 'rgba(0,0,0,0)');
                rad.addColorStop(1, 'rgba(0,0,0,0.6)');
                this.ctx.fillStyle = rad;
                this.ctx.fillRect(0,0,w,h);

                // Weapon & HUD
                this.drawWeapon(w, h, pitchOffset);
                this.drawHUD(w, h);
            }

            drawWeapon(w, h, pitchOffset) {
                const weapon = this.player.inventory[this.player.currentWeapon];
                const type = weapon.type || 'pistol';
                const isAiming = this.player.isAiming;

                // Bobbing / Sway
                const time = Date.now() / 150;
                const bobX = isAiming ? 0 : Math.sin(time) * 10 * (this.input.getMove().x || 0);
                const bobY = isAiming ? 0 : Math.abs(Math.sin(time*2)) * 10 * (this.input.getMove().y || 0);

                // Recoil
                const recoil = (Date.now() - this.player.lastFire < 150) ? (isAiming ? 5 : 20) : 0;

                // Reload Animation
                let reloadOffset = 0;
                if (this.player.reloading) {
                   const progress = (Date.now() - this.player.lastFire) / (weapon.reloadTime * 1000); // Hacky tracking
                   // We need better tracking for reload start, but for now we can infer or use a property
                   reloadOffset = Math.sin(Date.now() / 200) * 100; // Placeholder anim
                   if (isAiming) reloadOffset += 200; // Drop lower if aiming
                }

                // Position
                // Center X for ADS, Offset Right for Hip
                const centerX = w / 2;
                const rightX = w * 0.7;
                // Lerp between Hip and ADS
                const targetX = isAiming ? centerX : rightX;
                const gunX = targetX + bobX;
                const gunY = h - (isAiming ? 0 : h * 0.05) + bobY + recoil + reloadOffset + (pitchOffset * 0.8);
                // We drag the gun up/down with pitch slightly

                const scale = h / 600;

                this.ctx.save();
                this.ctx.translate(gunX, gunY);
                this.ctx.scale(scale, scale);

                if (type === 'pistol') {
                    // M1911 Style
                    this.ctx.fillStyle = '#333';
                    // Slide
                    this.ctx.fillRect(-20, -100, 40, 200);
                    // Grip (Visible if hip)
                    if (!isAiming) {
                        this.ctx.fillStyle = '#531';
                        this.ctx.fillRect(-15, 50, 30, 80);
                    }
                    // Iron Sights (ADS)
                    if (isAiming) {
                        // Rear Notch
                        this.ctx.fillStyle = '#111';
                        this.ctx.fillRect(-20, -100, 15, 40);
                        this.ctx.fillRect(5, -100, 15, 40);
                        // Front Post (Green)
                        this.ctx.fillStyle = '#0f0';
                        this.ctx.fillRect(-2, -95, 4, 10);
                    }
                } else if (type === 'rifle') {
                    // Kar98k Style
                    this.ctx.fillStyle = '#5A3A22'; // Wood
                    this.ctx.fillRect(-15, -150, 30, 400);

                    // Barrel
                    this.ctx.fillStyle = '#222';
                    this.ctx.fillRect(-5, -300, 10, 150);

                    // Iron Sights (ADS)
                    if (isAiming) {
                         // Rear Leaf
                        this.ctx.fillStyle = '#333';
                        this.ctx.beginPath();
                        this.ctx.moveTo(-30, 0);
                        this.ctx.lineTo(30, 0);
                        this.ctx.lineTo(0, 30);
                        this.ctx.fill();

                        // Front Post
                        this.ctx.fillStyle = '#000';
                        this.ctx.fillRect(-1, -145, 2, 20);
                    }
                } else if (type === 'scifi') {
                     // Ray Gun
                    this.ctx.fillStyle = '#a00';
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, 40, 0, Math.PI*2);
                    this.ctx.fill();

                    this.ctx.fillStyle = '#0f0';
                    this.ctx.fillRect(-10, -150, 20, 150);
                    // Rings
                    this.ctx.strokeStyle = '#0f0';
                    this.ctx.lineWidth = 4;
                    this.ctx.beginPath();
                    this.ctx.arc(0, -50, 25, 0, Math.PI*2);
                    this.ctx.stroke();
                    this.ctx.beginPath();
                    this.ctx.arc(0, -100, 20, 0, Math.PI*2);
                    this.ctx.stroke();

                    if (isAiming) {
                         // Crosshair inside sight
                        this.ctx.fillStyle = '#f00';
                        this.ctx.fillRect(-1, -150, 2, 20);
                        this.ctx.fillRect(-10, -140, 20, 2);
                    }
                }

                this.ctx.restore();
            }

            drawHUD(w, h) {
                const cx = w/2;
                const cy = h/2;

                // Crosshair (Only if not aiming)
                if (!this.player.isAiming) {
                     const spread = 10 + (this.input.isFiring() ? 20 : 0) + (Math.abs(this.input.getMove().x) + Math.abs(this.input.getMove().y))*5;

                     this.ctx.strokeStyle = '#0f0';
                     this.ctx.lineWidth = 2;
                     this.ctx.beginPath();
                     this.ctx.moveTo(cx - spread - 10, cy); this.ctx.lineTo(cx - spread, cy);
                     this.ctx.moveTo(cx + spread + 10, cy); this.ctx.lineTo(cx + spread, cy);
                     this.ctx.moveTo(cx, cy - spread - 10); this.ctx.lineTo(cx, cy - spread);
                     this.ctx.moveTo(cx, cy + spread + 10); this.ctx.lineTo(cx, cy + spread);
                     this.ctx.stroke();
                }

                // Hit Marker
                if (this.hitMarkerTime && Date.now() - this.hitMarkerTime < 100) {
                     this.ctx.strokeStyle = '#fff';
                     this.ctx.lineWidth = 3;
                     this.ctx.beginPath();
                     const s = 15; // Size
                     const o = 5;  // Offset
                     this.ctx.moveTo(cx - s, cy - s); this.ctx.lineTo(cx - o, cy - o);
                     this.ctx.moveTo(cx + s, cy - s); this.ctx.lineTo(cx + o, cy - o);
                     this.ctx.moveTo(cx - s, cy + s); this.ctx.lineTo(cx - o, cy + o);
                     this.ctx.moveTo(cx + s, cy + s); this.ctx.lineTo(cx + o, cy + o);
                     this.ctx.stroke();
                }
            }
        }

        // --- INPUT ---
        class InputHandler {
            constructor(game) {
                this.game = game;
                this.keys = {};
                this.buttons = { fire: false, action: false, reload: false, ads: false };
                this.touch = { lx: 0, ly: 0, rx: 0 };
                this.mouse = { x: 0, y: 0 };

                window.addEventListener('keydown', e => {
                    // Prevent default scrolling for game keys
                    if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Space'].includes(e.code)) e.preventDefault();

                    // Pause Toggle
                    if (e.code === 'Escape' || e.code === 'KeyP') {
                        this.game.togglePause(!this.game.paused);
                    }

                    this.keys[e.code] = true;
                });

                window.addEventListener('keyup', e => this.keys[e.code] = false);

                window.addEventListener('mousedown', e => {
                    if (document.pointerLockElement === document.getElementById('canvas')) {
                        if (e.button === 0) {
                             this.buttons.fire = true;
                        } else if (e.button === 2) { // Right Click
                            if (SETTINGS.toggleADS) {
                                this.buttons.ads = !this.buttons.ads;
                            } else {
                                this.buttons.ads = true;
                            }
                        }
                    } else if (!this.game.paused) {
                         // Click to capture if not paused
                        document.getElementById('canvas').requestPointerLock();
                    }
                });
                window.addEventListener('mouseup', e => {
                    if (e.button === 0) this.buttons.fire = false;
                    if (e.button === 2 && !SETTINGS.toggleADS) this.buttons.ads = false;
                });
                // Disable context menu
                window.addEventListener('contextmenu', e => e.preventDefault());

                this.bindTouch('btn-action', 'action');
                this.bindTouch('btn-reload', 'reload');
                this.bindTouch('btn-fire', 'fire');

                this.setupStick('stick-left', (x, y) => { this.touch.lx = x; this.touch.ly = y; });
                this.setupStick('stick-right', (x, y) => { this.touch.rx = x; });

                document.addEventListener('mousemove', (e) => {
                    if (document.pointerLockElement === document.getElementById('canvas')) {
                        this.mouse.x += e.movementX * 0.002;
                        this.mouse.y += e.movementY * 0.002;
                    }
                });
            }

            pollGamepads() {
                const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
                this.pad = null;
                // Find first active gamepad
                for (let i = 0; i < gamepads.length; i++) {
                    if (gamepads[i]) {
                        this.pad = gamepads[i];
                        break;
                    }
                }

                if (this.pad) {
                    // Update buttons
                    this.buttons.fire = this.pad.buttons[7].pressed; // R2
                    this.buttons.ads = this.pad.buttons[6].pressed;  // L2

                    // Square (Button 2): Interact Priority > Reload
                    if (this.pad.buttons[2].pressed) {
                         if (!this.padSquareDown) {
                             // Logic: If prompt visible, Interact. Else Reload.
                             const prompt = document.getElementById('prompt').style.display;
                             if (prompt === 'block') this.game.interact();
                             else this.game.reload();
                             this.padSquareDown = true;
                         }
                    } else { this.padSquareDown = false; }

                    // Triangle (Button 3): Switch Weapon
                    if (this.pad.buttons[3].pressed) {
                         if (!this.padTriDown) { this.game.switchWeapon(); this.padTriDown = true; }
                    } else { this.padTriDown = false; }

                    // Cross (Button 0): Jump
                    if (this.pad.buttons[0].pressed) {
                         if (!this.padCrossDown) { this.game.jump(); this.padCrossDown = true; }
                    } else { this.padCrossDown = false; }

                    // Circle (Button 1): Melee
                    if (this.pad.buttons[1].pressed) {
                         if (!this.padCircleDown) { this.game.melee(); this.padCircleDown = true; }
                    } else { this.padCircleDown = false; }

                    // L3 (Button 10): Sprint Toggle
                    if (this.pad.buttons[10].pressed) {
                         if (!this.padL3Down) { this.game.toggleSprint(); this.padL3Down = true; }
                    } else { this.padL3Down = false; }

                    // R3 (Button 11): Crouch Toggle
                    if (this.pad.buttons[11].pressed) {
                         if (!this.padR3Down) { this.game.toggleCrouch(); this.padR3Down = true; }
                    } else { this.padR3Down = false; }

                    // R1 (Button 5): Grenade
                    if (this.pad.buttons[5].pressed) {
                         if (!this.padR1Down) { this.game.throwGrenade(); this.padR1Down = true; }
                    } else { this.padR1Down = false; }

                    // Start (Button 9): Pause
                    if (this.pad.buttons[9].pressed) { // Start
                         if (!this.padStartDown) { this.game.togglePause(!this.game.paused); this.padStartDown = true; }
                    } else { this.padStartDown = false; }
                }
            }

            haptic(duration=100, strong=1.0, weak=1.0) {
                 if (SETTINGS.vibrationIntensity <= 0) return;
                 if (this.pad && this.pad.vibrationActuator) {
                     this.pad.vibrationActuator.playEffect("dual-rumble", {
                        startDelay: 0,
                        duration: duration,
                        weakMagnitude: weak * SETTINGS.vibrationIntensity,
                        strongMagnitude: strong * SETTINGS.vibrationIntensity
                    });
                 }
            }

            hapticSequence(sequence) {
                 // sequence: [{ delay: ms, duration: ms, strong: 0-1, weak: 0-1 }, ...]
                 if (SETTINGS.vibrationIntensity <= 0) return;
                 sequence.forEach(step => {
                      setTimeout(() => {
                           this.haptic(step.duration, step.strong, step.weak);
                      }, step.delay);
                 });
            }

            bindTouch(id, action) {
                const btn = document.getElementById(id);
                btn.addEventListener('touchstart', (e) => { e.preventDefault(); this.buttons[action] = true; });
                btn.addEventListener('touchend', (e) => { e.preventDefault(); this.buttons[action] = false; });
            }

            setupStick(id, cb) {
                const el = document.getElementById(id);
                const knob = el.querySelector('.touch-knob');
                const handle = (e) => {
                    e.preventDefault();
                    const rect = el.getBoundingClientRect();
                    const touch = e.changedTouches[0];
                    const cx = rect.left + rect.width/2;
                    const cy = rect.top + rect.height/2;
                    const maxR = rect.width/2;
                    let dx = touch.clientX - cx;
                    let dy = touch.clientY - cy;
                    const dist = Math.min(Math.sqrt(dx*dx+dy*dy), maxR);
                    const angle = Math.atan2(dy, dx);
                    dx = Math.cos(angle) * dist;
                    dy = Math.sin(angle) * dist;
                    knob.style.transform = `translate(-50%, -50%) translate(${dx}px, ${dy}px)`;
                    cb(dx/maxR, dy/maxR);
                };
                el.addEventListener('touchstart', handle, {passive:false});
                el.addEventListener('touchmove', handle, {passive:false});
                el.addEventListener('touchend', () => {
                    knob.style.transform = `translate(-50%, -50%)`;
                    cb(0,0);
                });
            }

            // Maps physical input to game actions via SETTINGS
            isAction(action) {
                const key = SETTINGS.keys[action];
                return this.keys[key];
            }

            getMove() {
                let x = 0, y = 0;
                if (this.isAction('forward')) y += 1;
                if (this.isAction('backward')) y -= 1;
                if (this.isAction('left')) x -= 1;
                if (this.isAction('right')) x += 1;

                // Touch
                if (Math.abs(this.touch.lx) > 0.1) x += this.touch.lx;
                if (Math.abs(this.touch.ly) > 0.1) y -= this.touch.ly;

                // Gamepad
                if (this.pad) {
                    const dz = SETTINGS.deadzone;
                    const ax0 = this.pad.axes[0]; // Left Stick X
                    const ax1 = this.pad.axes[1]; // Left Stick Y
                    if (Math.abs(ax0) > dz) x += ax0;
                    if (Math.abs(ax1) > dz) y -= ax1; // Invert Y for standard "forward is negative" usually, but here forward is +y in logic? No, forward is +y in map? Wait, usually forward key adds +1.
                    // Wait, logic above: Forward adds +1 to Y.
                    // Gamepad Axis 1: Down is +, Up is -. So Up (-1) needs to be +1. So Invert.
                }

                return { x, y };
            }

            getLook() {
                let x = 0, y = 0;

                // Keyboard Arrows (Legacy)
                if (this.keys['ArrowLeft']) x -= 1;
                if (this.keys['ArrowRight']) x += 1;
                if (this.keys['ArrowUp']) y -= 1;
                if (this.keys['ArrowDown']) y += 1;

                // Mouse Look (Base Sensitivity)
                if (Math.abs(this.mouse.x) > 0.001) {
                    let mx = this.mouse.x;
                    if (SETTINGS.invertX) mx = -mx;
                    x += mx * 2.0;
                }
                if (Math.abs(this.mouse.y) > 0.001) {
                    let my = this.mouse.y;
                    if (SETTINGS.invertY) my = -my;
                    y += my * 2.0;
                }

                // Touch
                if (Math.abs(this.touch.rx) > 0.1) x += this.touch.rx * 2.0;

                // Gamepad (Advanced Sensitivity)
                if (this.pad) {
                    const dz = SETTINGS.deadzone;
                    const ax2 = this.pad.axes[2]; // Right Stick X
                    const ax3 = this.pad.axes[3]; // Right Stick Y

                    // Apply ADS Multiplier
                    const mult = this.isAiming() ? SETTINGS.adsMult : 1.0;

                    if (Math.abs(ax2) > dz) {
                         let val = ax2 * SETTINGS.sensX * mult * 0.05; // Scale down for frame delta
                         if (SETTINGS.invertX) val = -val;
                         x += val;
                    }
                    if (Math.abs(ax3) > dz) {
                         let val = ax3 * SETTINGS.sensY * mult * 0.05;
                         if (SETTINGS.invertY) val = -val;
                         y -= val; // Up is -1, so invert to look up (+pitch) ??
                         // Logic check: Pitch += rot.y. Looking Up usually increases pitch? Or decreases?
                         // In update(): pitch += rot.y * sens.
                         // Mouse Y down (+movement) -> Look Down (-pitch)?
                         // Usually Mouse Y+ -> Look Down.
                         // Gamepad Axis 3 Down -> +1.
                         // So +1 should be Look Down.
                         // So we want +y.
                         // So remove negate?
                         // Let's stick to standard: Axis 3 positive is DOWN. Look needs to be positive to add to pitch?
                         // Let's re-verify mouse logic:
                         // Mouse Y+ (Down) -> y += my.
                         // rot.y is positive.
                         // Pitch += rot.y.
                         // render(): pitchOffset = pitch.
                         // drawStart = -lineHeight/2 + h/2 + pitchOffset.
                         // If pitch is positive, drawStart increases (moves down).
                         // If drawStart moves down, the world moves down?
                         // If the world moves down on screen, you are looking UP.
                         // WAIT.
                         // If I look UP, the horizon should move DOWN on the screen.
                         // So Pitch Positive = Look Up.
                         // Mouse Y+ (Down) should be Look Down.
                         // So Mouse Y+ should result in Pitch Negative.
                         // Currently: Mouse Y+ -> y+= positive -> Pitch += positive -> Look Up.
                         // ERROR: Mouse Logic is Inverted by default in my previous code!
                         // But user didn't complain? Maybe they just inverted it in menu?
                         // Let's fix standard gamepad: Axis 3 Down (+) -> Look Down (Pitch -).
                         // So y -= val is correct if val is positive.
                    }
                }

                this.mouse.x = 0; // Reset frame delta
                this.mouse.y = 0;

                return { x, y };
            }

            isAiming() { return this.buttons.ads; }
            isFiring() { return this.keys['Space'] || this.buttons.fire; }
        }

        function shadeColor(color, percent) {
            // Parses hex, shades it, returns new hex
            if (color.length !== 7) return color;
            let R = parseInt(color.substring(1,3),16);
            let G = parseInt(color.substring(3,5),16);
            let B = parseInt(color.substring(5,7),16);

            R = parseInt(R * (100 + percent) / 100);
            G = parseInt(G * (100 + percent) / 100);
            B = parseInt(B * (100 + percent) / 100);

            R = (R<255)?R:255;
            G = (G<255)?G:255;
            B = (B<255)?B:255;

            const RR = ((R.toString(16).length==1)?"0"+R.toString(16):R.toString(16));
            const GG = ((G.toString(16).length==1)?"0"+G.toString(16):G.toString(16));
            const BB = ((B.toString(16).length==1)?"0"+B.toString(16):B.toString(16));

            return "#"+RR+GG+BB;
        }

        window.onload = () => new Game();
    </script>
</body>
</html>
