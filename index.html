<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Web of the Dead: Nacht Der Untoten (FPS V5)</title>
    <script>
        console.log("GAME VERSION: FPS V5 (Anti-Freeze) LOADED");
        // Force unregister any potential service workers
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.getRegistrations().then(function(registrations) {
                for(let registration of registrations) {
                    registration.unregister();
                }
            });
        }
    </script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; color: #fff; font-family: Courier, monospace; touch-action: none; user-select: none; }
        canvas { display: block; width: 100%; height: 100%; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        .hud { position: absolute; text-shadow: 2px 2px 0 #000; font-weight: bold; }
        #score { top: 20px; left: 20px; font-size: 24px; color: #ffd700; }
        #round { bottom: 20px; left: 20px; font-size: 36px; color: #bd0000; }
        #ammo { bottom: 20px; right: 20px; text-align: right; font-size: 24px; }
        #prompt { top: 60%; left: 50%; transform: translate(-50%, -50%); font-size: 20px; background: rgba(0,0,0,0.7); padding: 10px; display: none; }
        #damage { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: red; opacity: 0; transition: opacity 0.2s; pointer-events: none; }
        #game-over { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(50,0,0,0.9); display: none; flex-direction: column; justify-content: center; align-items: center; pointer-events: auto; }
        #game-over h1 { color: #bd0000; font-size: 60px; margin: 0; }
        #game-over button { margin-top: 20px; padding: 15px 30px; font-size: 24px; cursor: pointer; background: #444; color: #fff; border: 2px solid #fff; }
        #fps-mode { position: absolute; top: 20px; right: 20px; color: #0f0; font-size: 16px; opacity: 0.7; }

        /* Pause Menu */
        #pause-menu { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); display: none; flex-direction: column; align-items: center; justify-content: center; pointer-events: auto; z-index: 100; }
        #pause-menu h1 { color: #fff; font-size: 40px; margin-bottom: 20px; }
        .menu-section { width: 80%; max-width: 400px; margin-bottom: 20px; border: 1px solid #444; padding: 10px; background: rgba(50,50,50,0.5); }
        .menu-section h3 { margin-top: 0; border-bottom: 1px solid #666; padding-bottom: 5px; }
        .setting-row { display: flex; justify-content: space-between; align-items: center; margin: 10px 0; }
        .setting-row label { font-size: 18px; }
        .setting-row input[type="range"] { width: 50%; }
        .setting-row input[type="checkbox"] { width: 20px; height: 20px; }
        .key-bind { background: #333; padding: 5px 10px; border: 1px solid #666; cursor: pointer; min-width: 80px; text-align: center; }
        .key-bind:hover { background: #555; }
        .key-bind.listening { background: #d00; color: white; border-color: red; }
        button.menu-btn { padding: 10px 20px; font-size: 20px; cursor: pointer; background: #444; color: #fff; border: 2px solid #fff; margin-top: 10px; }
        button.menu-btn:hover { background: #666; }

        /* Mobile Controls */
        .touch-zone { position: absolute; bottom: 20px; width: 150px; height: 150px; border: 2px solid rgba(255,255,255,0.3); border-radius: 50%; pointer-events: auto; display: none; }
        .touch-knob { width: 50px; height: 50px; background: rgba(255,255,255,0.5); border-radius: 50%; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); pointer-events: none; }
        #stick-left { left: 20px; }
        #stick-right { right: 20px; }
        #btn-action { position: absolute; bottom: 180px; right: 40px; width: 80px; height: 80px; background: rgba(0,255,0,0.3); border: 2px solid #0f0; border-radius: 50%; display: none; justify-content: center; align-items: center; font-size: 30px; pointer-events: auto; }
        #btn-reload { position: absolute; bottom: 180px; right: 140px; width: 60px; height: 60px; background: rgba(255,255,0,0.3); border: 2px solid #ff0; border-radius: 50%; display: none; justify-content: center; align-items: center; font-size: 20px; pointer-events: auto; }
        #btn-fire { position: absolute; bottom: 80px; right: 180px; width: 80px; height: 80px; background: rgba(255,0,0,0.3); border: 2px solid #f00; border-radius: 50%; display: none; justify-content: center; align-items: center; font-size: 20px; pointer-events: auto; }

        @media (hover: none) and (pointer: coarse) {
            .touch-zone, #btn-action, #btn-reload, #btn-fire { display: flex; }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="ui-layer">
        <div id="damage"></div>
        <div id="fps-mode">FPS MODE V5</div>
        <div id="score" class="hud">Points: 500</div>
        <div id="round" class="hud">I</div>
        <div id="ammo" class="hud">M1911<br>8 / 32</div>
        <div id="prompt" class="hud">Press F to Interact</div>

        <!-- Pause Menu -->
        <div id="pause-menu">
            <h1>PAUSED</h1>

            <div class="menu-section">
                <h3>Controls</h3>
                <div class="setting-row">
                    <label>Sensitivity</label>
                    <input type="range" id="sens-slider" min="1" max="10" step="0.5" value="3.0">
                    <span id="sens-val">3.0</span>
                </div>
                <div class="setting-row">
                    <label>Invert Y</label>
                    <input type="checkbox" id="invert-y">
                </div>
                <div class="setting-row">
                    <label>Invert X</label>
                    <input type="checkbox" id="invert-x">
                </div>
            </div>

            <div class="menu-section">
                <h3>Key Bindings (Click to Remap)</h3>
                <div class="setting-row">
                    <label>Forward</label>
                    <div class="key-bind" data-action="forward">W</div>
                </div>
                <div class="setting-row">
                    <label>Backward</label>
                    <div class="key-bind" data-action="backward">S</div>
                </div>
                <div class="setting-row">
                    <label>Left</label>
                    <div class="key-bind" data-action="left">A</div>
                </div>
                <div class="setting-row">
                    <label>Right</label>
                    <div class="key-bind" data-action="right">D</div>
                </div>
                <div class="setting-row">
                    <label>Interact</label>
                    <div class="key-bind" data-action="interact">F</div>
                </div>
                <div class="setting-row">
                    <label>Reload</label>
                    <div class="key-bind" data-action="reload">R</div>
                </div>
            </div>

            <button class="menu-btn" id="resume-btn">RESUME</button>
        </div>

        <div id="stick-left" class="touch-zone"><div class="touch-knob"></div></div>
        <div id="stick-right" class="touch-zone"><div class="touch-knob"></div></div>
        <div id="btn-action">üñêÔ∏è</div>
        <div id="btn-reload">‚Üª</div>
        <div id="btn-fire">üî•</div>

        <div id="game-over">
            <h1>GAME OVER</h1>
            <h2 id="final-score">Score: 0</h2>
            <h3 id="final-round">Round: 1</h3>
            <button onclick="location.reload()">TRY AGAIN</button>
        </div>
    </div>

    <script>
        // --- CONSTANTS ---
        const C = {
            FOV: Math.PI / 3,
            RES: 2, // 1=High, 2=Med, 4=Low
            MAX_DEPTH: 20,
            MOVE_SPEED: 3.0,
            ROT_SPEED_BASE: 2.0, // Base speed multiplier
            PLAYER_RADIUS: 0.3,
            MAP_SIZE: 20
        };

        // --- MAP & ASSETS ---
        const MAP = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,2,1,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,1],
            [1,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1],
            [1,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1],
            [1,0,1,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,1],
            [1,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1],
            [1,0,1,1,1,3,1,1,1,2,1,1,1,1,0,0,0,0,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];
        for(let i=MAP.length; i<20; i++) MAP.push(new Array(20).fill(1));

        const OBJECTS = [
            { type: 'door', x: 6, y: 3, cost: 1000, targetZone: 1, open: false },
            { type: 'door', x: 5, y: 10, cost: 1000, targetZone: 2, open: false },
            { type: 'window', x: 1, y: 5, boards: 6, maxBoards: 6, lastDamage: 0 },
            { type: 'window', x: 13, y: 8, boards: 6, maxBoards: 6, lastDamage: 0 },
            { type: 'window', x: 9, y: 10, boards: 6, maxBoards: 6, lastDamage: 0 },
            { type: 'wallbuy', x: 2, y: 1, weapon: 'Kar98k', cost: 200 }
        ];

        const WEAPONS = {
            'M1911': { name: 'M1911', damage: 20, fireRate: 0.4, magSize: 8, reserveMax: 32, reloadTime: 1.5, spread: 0.05, color: '#555' },
            'Kar98k': { name: 'Kar98k', damage: 100, fireRate: 1.0, magSize: 5, reserveMax: 50, reloadTime: 2.5, spread: 0.01, color: '#8B4513' },
            'RayGun': { name: 'Ray Gun', damage: 1000, fireRate: 0.3, magSize: 20, reserveMax: 160, reloadTime: 3.0, spread: 0.0, color: '#0f0' }
        };

        // --- SETTINGS ---
        const SETTINGS = {
            sensitivity: 3.0,
            invertY: false,
            invertX: false,
            keys: {
                forward: 'KeyW',
                backward: 'KeyS',
                left: 'KeyA',
                right: 'KeyD',
                interact: 'KeyF',
                reload: 'KeyR'
            }
        };

        // --- GAME ---
        class Game {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d', { alpha: false });
                this.resize();

                this.player = {
                    x: 3.5, y: 2.5, dir: 0,
                    health: 100, maxHealth: 100,
                    lastDamage: 0,
                    score: 500,
                    inventory: [ { ...WEAPONS['M1911'], currentMag: 8, reserve: 32 } ],
                    currentWeapon: 0,
                    lastFire: 0, reloading: false
                };

                this.zombies = [];
                this.bullets = [];
                this.round = 1;
                this.spawnTimer = 0;
                this.zombiesToSpawn = 5;
                this.lastTime = 0;
                this.running = true;
                this.paused = false;

                this.input = new InputHandler(this);
                this.setupUI();

                // Bindings
                this.loop = this.loop.bind(this);
                requestAnimationFrame(this.loop);
            }

            setupUI() {
                // Settings UI Handlers
                const slider = document.getElementById('sens-slider');
                const valDisplay = document.getElementById('sens-val');
                slider.addEventListener('input', (e) => {
                    SETTINGS.sensitivity = parseFloat(e.target.value);
                    valDisplay.innerText = SETTINGS.sensitivity.toFixed(1);
                });

                document.getElementById('invert-y').addEventListener('change', e => SETTINGS.invertY = e.target.checked);
                document.getElementById('invert-x').addEventListener('change', e => SETTINGS.invertX = e.target.checked);
                document.getElementById('resume-btn').addEventListener('click', () => this.togglePause(false));

                // Key Rebinding
                document.querySelectorAll('.key-bind').forEach(el => {
                    el.addEventListener('click', () => {
                        el.classList.add('listening');
                        el.innerText = 'Press Key...';

                        const handler = (e) => {
                            e.preventDefault();
                            const action = el.dataset.action;
                            SETTINGS.keys[action] = e.code;
                            el.innerText = e.code.replace('Key', '');
                            el.classList.remove('listening');
                            window.removeEventListener('keydown', handler);

                            // Re-init input keys
                            this.input.keys[e.code] = false; // Reset state
                        };
                        window.addEventListener('keydown', handler, { once: true });
                    });
                });
            }

            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.ctx.imageSmoothingEnabled = false;
            }

            togglePause(state) {
                this.paused = state;
                const menu = document.getElementById('pause-menu');
                if (this.paused) {
                    menu.style.display = 'flex';
                    document.exitPointerLock();
                    this.lastTime = 0; // Reset delta time
                } else {
                    menu.style.display = 'none';
                    this.canvas.requestPointerLock();
                    this.lastTime = performance.now();
                }
            }

            loop(timestamp) {
                if (!this.running) return;

                if (this.lastTime === 0) this.lastTime = timestamp; // First frame fix
                const dt = (timestamp - this.lastTime) / 1000;

                if (!this.paused) {
                    this.update(Math.min(dt, 0.1));
                    this.render();
                }

                this.lastTime = timestamp;
                requestAnimationFrame(this.loop);
            }

            update(dt) {
                if (this.player.health <= 0) return this.gameOver();

                // Health Regen
                if (this.player.health < this.player.maxHealth && Date.now() - this.player.lastDamage > 5000) {
                    this.player.health += 20 * dt;
                    if (this.player.health > this.player.maxHealth) this.player.health = this.player.maxHealth;
                    this.updateHUD();
                }

                // Player Movement
                const move = this.input.getMove();
                const rot = this.input.getLook();

                // Apply Sensitivity
                this.player.dir += rot.x * C.ROT_SPEED_BASE * SETTINGS.sensitivity * dt;
                // Normalize player direction to prevent large values causing freezes
                this.player.dir = (this.player.dir % (2 * Math.PI));

                const speed = C.MOVE_SPEED * dt;
                const cos = Math.cos(this.player.dir);
                const sin = Math.sin(this.player.dir);

                // Move Vector relative to direction
                let dx = (cos * move.y - sin * move.x) * speed;
                let dy = (sin * move.y + cos * move.x) * speed;

                if (MAP[Math.floor(this.player.y)][Math.floor(this.player.x + dx * 2)] === 0) this.player.x += dx;
                if (MAP[Math.floor(this.player.y + dy * 2)][Math.floor(this.player.x)] === 0) this.player.y += dy;

                // Input Actions
                if (this.input.isAction('reload')) this.reload();
                if (this.input.isFiring()) this.fire(timestamp = Date.now());
                if (this.input.isAction('interact') || this.input.buttons.action) this.interact();

                // Pause Toggle (Debounced slightly handled in InputHandler)

                // Zombie Spawning
                if (this.zombiesToSpawn > 0) {
                    this.spawnTimer += dt;
                    if (this.spawnTimer > 3.0) {
                        this.spawnZombie();
                        this.spawnTimer = 0;
                        this.zombiesToSpawn--;
                    }
                } else if (this.zombies.length === 0) {
                    this.round++;
                    this.zombiesToSpawn = Math.floor(5 * Math.pow(1.2, this.round-1));
                    document.getElementById('round').innerText = this.toRoman(this.round);
                }

                // Zombie Logic
                this.zombies.forEach(z => {
                    const dist = Math.sqrt((this.player.x - z.x)**2 + (this.player.y - z.y)**2);
                    if (dist > 0.5) {
                        const angle = Math.atan2(this.player.y - z.y, this.player.x - z.x);
                        let zdx = Math.cos(angle) * dt * (0.8 + this.round * 0.05);
                        let zdy = Math.sin(angle) * dt * (0.8 + this.round * 0.05);

                        if (MAP[Math.floor(z.y)][Math.floor(z.x + zdx * 1.5)] <= 0) z.x += zdx; // Allow walking through empty(0)
                        if (MAP[Math.floor(z.y + zdy * 1.5)][Math.floor(z.x)] <= 0) z.y += zdy;
                    } else {
                        if (Date.now() - z.lastAttack > 1000) {
                            this.player.health -= 20;
                            this.player.lastDamage = Date.now();
                            z.lastAttack = Date.now();
                            this.updateHUD();
                        }
                    }
                });
                this.zombies = this.zombies.filter(z => z.health > 0);

                // Check Interactable Prompt
                this.checkInteraction();
            }

            spawnZombie() {
                const w = OBJECTS.filter(o => o.type === 'window')[0]; // Just use first window for prototype
                if(w) this.zombies.push({ x: w.x, y: w.y, health: 100 * Math.pow(1.1, this.round-1), lastAttack: 0 });
            }

            fire(time) {
                const w = this.player.inventory[this.player.currentWeapon];
                if (time - this.player.lastFire > w.fireRate * 1000 && w.currentMag > 0 && !this.player.reloading) {
                    w.currentMag--;
                    this.player.lastFire = time;
                    this.updateHUD();

                    // Hitscan Logic
                    let closestDist = Infinity;
                    let hitZombie = null;

                    this.zombies.forEach(z => {
                        const angleToZ = Math.atan2(z.y - this.player.y, z.x - this.player.x);
                        let angleDiff = angleToZ - this.player.dir;

                        // Robust normalization to [-PI, PI] using trig (avoids loops)
                        angleDiff = Math.atan2(Math.sin(angleDiff), Math.cos(angleDiff));

                        if (Math.abs(angleDiff) < 0.1) { // Hit cone
                            const d = Math.sqrt((this.player.x - z.x)**2 + (this.player.y - z.y)**2);
                            if (d < closestDist) {
                                closestDist = d;
                                hitZombie = z;
                            }
                        }
                    });

                    if (hitZombie) {
                        hitZombie.health -= w.damage;
                        this.player.score += 10;
                        if (hitZombie.health <= 0) this.player.score += 60;
                        this.updateHUD();
                    }
                }
            }

            reload() {
                const w = this.player.inventory[this.player.currentWeapon];
                if (!this.player.reloading && w.currentMag < w.magSize && w.reserve > 0) {
                    this.player.reloading = true;
                    document.getElementById('ammo').innerText = "RELOADING...";
                    setTimeout(() => {
                        const needed = w.magSize - w.currentMag;
                        const taken = Math.min(needed, w.reserve);
                        w.currentMag += taken;
                        w.reserve -= taken;
                        this.player.reloading = false;
                        this.updateHUD();
                    }, w.reloadTime * 1000);
                }
            }

            interact() {
                // Check closest interactable in front
                let target = null;
                let minDist = 2.0;

                OBJECTS.forEach(obj => {
                    const d = Math.sqrt((this.player.x - obj.x)**2 + (this.player.y - obj.y)**2);
                    if (d < minDist) {
                        target = obj;
                        minDist = d;
                    }
                });

                if (target) {
                    if (target.type === 'window') {
                        if (target.boards < target.maxBoards) {
                            target.boards++;
                            this.player.score += 10;
                            this.updateHUD();
                        }
                    } else if (target.type === 'door' && !target.open) {
                        if (this.player.score >= target.cost) {
                            this.player.score -= target.cost;
                            target.open = true;
                            MAP[target.y][target.x] = 4; // Open Door ID
                            this.updateHUD();
                        }
                    } else if (target.type === 'wallbuy') {
                        if (this.player.score >= target.cost) {
                            const newWep = WEAPONS[target.weapon];
                            // Replace current or add? Simply replace for prototype
                            this.player.inventory[0] = { ...newWep, currentMag: newWep.magSize, reserve: newWep.reserveMax };
                            this.player.score -= target.cost;
                            this.updateHUD();
                        }
                    }
                }
            }

            checkInteraction() {
                let prompt = "";
                let minDist = 2.0;
                OBJECTS.forEach(obj => {
                    const d = Math.sqrt((this.player.x - obj.x)**2 + (this.player.y - obj.y)**2);
                    if (d < minDist) {
                        if (obj.type === 'window' && obj.boards < obj.maxBoards) prompt = "Repair Window";
                        if (obj.type === 'door' && !obj.open) prompt = `Open Door [${obj.cost}]`;
                        if (obj.type === 'wallbuy') prompt = `Buy ${obj.weapon} [${obj.cost}]`;
                    }
                });
                const el = document.getElementById('prompt');
                if (prompt) {
                    el.style.display = 'block';
                    el.innerText = `Press ${SETTINGS.keys.interact.replace('Key','')} to: ` + prompt;
                } else {
                    el.style.display = 'none';
                }
            }

            updateHUD() {
                const w = this.player.inventory[this.player.currentWeapon];
                document.getElementById('ammo').innerHTML = `${w.name}<br>${w.currentMag} / ${w.reserve}`;
                document.getElementById('score').innerText = `Points: ${this.player.score}`;
                document.getElementById('damage').style.opacity = (1 - this.player.health/100) * 0.8;
            }

            gameOver() {
                this.running = false;
                document.getElementById('game-over').style.display = 'flex';
                document.getElementById('final-score').innerText = 'Score: ' + this.player.score;
                document.getElementById('final-round').innerText = 'Round: ' + this.round;
                document.exitPointerLock();
            }

            toRoman(num) {
                if (num === 1) return "I";
                if (num === 2) return "II";
                if (num === 3) return "III";
                if (num === 4) return "IV";
                return num.toString();
            }

            render() {
                const w = this.canvas.width;
                const h = this.canvas.height;
                const mw = w / C.RES;

                // Ceiling/Floor
                this.ctx.fillStyle = '#111';
                this.ctx.fillRect(0,0,w,h/2);
                this.ctx.fillStyle = '#222';
                this.ctx.fillRect(0,h/2,w,h/2);

                const zBuffer = new Array(Math.ceil(mw)).fill(0);

                // Raycast Walls
                for(let x=0; x<mw; x++) {
                    const cameraX = 2 * x / mw - 1;
                    const rayDirX = Math.cos(this.player.dir) + Math.cos(this.player.dir + Math.PI/2) * cameraX * 0.66;
                    const rayDirY = Math.sin(this.player.dir) + Math.sin(this.player.dir + Math.PI/2) * cameraX * 0.66;

                    let mapX = Math.floor(this.player.x);
                    let mapY = Math.floor(this.player.y);
                    let sideDistX, sideDistY, perpWallDist, side, hit=0;
                    const deltaDistX = Math.abs(1/rayDirX);
                    const deltaDistY = Math.abs(1/rayDirY);
                    const stepX = (rayDirX < 0) ? -1 : 1;
                    const stepY = (rayDirY < 0) ? -1 : 1;

                    if (rayDirX < 0) sideDistX = (this.player.x - mapX) * deltaDistX;
                    else sideDistX = (mapX + 1.0 - this.player.x) * deltaDistX;
                    if (rayDirY < 0) sideDistY = (this.player.y - mapY) * deltaDistY;
                    else sideDistY = (mapY + 1.0 - this.player.y) * deltaDistY;

                    // DDA
                    let dist = 0;
                    while (hit === 0 && dist < C.MAX_DEPTH) {
                        if (sideDistX < sideDistY) { sideDistX += deltaDistX; mapX += stepX; side = 0; }
                        else { sideDistY += deltaDistY; mapY += stepY; side = 1; }

                        if (MAP[mapY] && MAP[mapY][mapX] > 0 && MAP[mapY][mapX] !== 4) hit = MAP[mapY][mapX]; // 4 is open door (empty)
                        dist++;
                    }

                    if (side === 0) perpWallDist = (mapX - this.player.x + (1 - stepX) / 2) / rayDirX;
                    else perpWallDist = (mapY - this.player.y + (1 - stepY) / 2) / rayDirY;

                    zBuffer[x] = perpWallDist;

                    const lineHeight = Math.floor(h / perpWallDist);
                    const drawStart = -lineHeight / 2 + h / 2;
                    let color = (hit === 1) ? '#666' : (hit === 2) ? '#8B4513' : (hit === 3) ? '#553311' : '#444';

                    // Simple Shader
                    if (side === 1) color = shadeColor(color, -20);
                    // Distance fading
                    const fade = Math.min(1, perpWallDist / C.MAX_DEPTH);
                    color = shadeColor(color, -fade * 50);

                    this.ctx.fillStyle = color;
                    this.ctx.fillRect(x * C.RES, drawStart, C.RES, lineHeight);
                }

                // Sprite Casting (Zombies)
                this.zombies.forEach(z => {
                    const dx = z.x - this.player.x;
                    const dy = z.y - this.player.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);

                    // Angle to sprite relative to player angle
                    const spriteAngle = Math.atan2(dy, dx) - this.player.dir;
                    let diff = spriteAngle;
                    while(diff < -Math.PI) diff += 2*Math.PI;
                    while(diff > Math.PI) diff -= 2*Math.PI;

                    // Only draw if in front
                    if (Math.abs(diff) < C.FOV / 1.5) {
                        const screenX = (0.5 * (diff / (C.FOV / 2)) + 0.5) * w;
                        const spriteH = h / dist;
                        const spriteW = spriteH * 0.6; // Zombies are tall
                        const spriteTop = (h - spriteH) / 2;

                        const zBufIdx = Math.floor(screenX / C.RES);
                        if (zBufIdx >= 0 && zBufIdx < mw && dist < zBuffer[zBufIdx]) {
                            this.ctx.fillStyle = '#0f0'; // Zombie Green
                            this.ctx.fillRect(screenX - spriteW/2, spriteTop, spriteW, spriteH);

                            // Eyes
                            this.ctx.fillStyle = '#f00';
                            this.ctx.fillRect(screenX - spriteW*0.2, spriteTop + spriteH*0.2, spriteW*0.1, spriteW*0.1);
                            this.ctx.fillRect(screenX + spriteW*0.1, spriteTop + spriteH*0.2, spriteW*0.1, spriteW*0.1);
                        }
                    }
                });

                // Gun Model
                const weapon = this.player.inventory[this.player.currentWeapon];
                this.ctx.fillStyle = weapon.color || '#555';
                const gunW = w * 0.15;
                const gunH = h * 0.25;
                const gunX = w/2 - gunW/2 + (this.player.reloading ? 0 : Math.sin(Date.now()/100)*5); // Idle sway
                const gunY = h - gunH + (this.input.isFiring() ? 10 : 0) + (this.player.reloading ? 50 : 0); // Recoil/Reload anim

                this.ctx.fillRect(gunX, gunY, gunW, gunH);
            }
        }

        // --- INPUT ---
        class InputHandler {
            constructor(game) {
                this.game = game;
                this.keys = {};
                this.buttons = { fire: false, action: false, reload: false };
                this.touch = { lx: 0, ly: 0, rx: 0 };
                this.mouse = { x: 0 };

                window.addEventListener('keydown', e => {
                    // Prevent default scrolling for game keys
                    if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Space'].includes(e.code)) e.preventDefault();

                    // Pause Toggle
                    if (e.code === 'Escape' || e.code === 'KeyP') {
                        this.game.togglePause(!this.game.paused);
                    }

                    this.keys[e.code] = true;
                });

                window.addEventListener('keyup', e => this.keys[e.code] = false);

                window.addEventListener('mousedown', e => {
                    if (document.pointerLockElement === document.getElementById('canvas')) {
                        if (e.button === 0) this.buttons.fire = true;
                    } else if (!this.game.paused) {
                         // Click to capture if not paused
                        document.getElementById('canvas').requestPointerLock();
                    }
                });
                window.addEventListener('mouseup', e => {
                    if (e.button === 0) this.buttons.fire = false;
                });

                this.bindTouch('btn-action', 'action');
                this.bindTouch('btn-reload', 'reload');
                this.bindTouch('btn-fire', 'fire');

                this.setupStick('stick-left', (x, y) => { this.touch.lx = x; this.touch.ly = y; });
                this.setupStick('stick-right', (x, y) => { this.touch.rx = x; });

                document.addEventListener('mousemove', (e) => {
                    if (document.pointerLockElement === document.getElementById('canvas')) {
                        this.mouse.x += e.movementX * 0.002;
                    }
                });
            }

            bindTouch(id, action) {
                const btn = document.getElementById(id);
                btn.addEventListener('touchstart', (e) => { e.preventDefault(); this.buttons[action] = true; });
                btn.addEventListener('touchend', (e) => { e.preventDefault(); this.buttons[action] = false; });
            }

            setupStick(id, cb) {
                const el = document.getElementById(id);
                const knob = el.querySelector('.touch-knob');
                const handle = (e) => {
                    e.preventDefault();
                    const rect = el.getBoundingClientRect();
                    const touch = e.changedTouches[0];
                    const cx = rect.left + rect.width/2;
                    const cy = rect.top + rect.height/2;
                    const maxR = rect.width/2;
                    let dx = touch.clientX - cx;
                    let dy = touch.clientY - cy;
                    const dist = Math.min(Math.sqrt(dx*dx+dy*dy), maxR);
                    const angle = Math.atan2(dy, dx);
                    dx = Math.cos(angle) * dist;
                    dy = Math.sin(angle) * dist;
                    knob.style.transform = `translate(-50%, -50%) translate(${dx}px, ${dy}px)`;
                    cb(dx/maxR, dy/maxR);
                };
                el.addEventListener('touchstart', handle, {passive:false});
                el.addEventListener('touchmove', handle, {passive:false});
                el.addEventListener('touchend', () => {
                    knob.style.transform = `translate(-50%, -50%)`;
                    cb(0,0);
                });
            }

            // Maps physical input to game actions via SETTINGS
            isAction(action) {
                const key = SETTINGS.keys[action];
                return this.keys[key];
            }

            getMove() {
                let x = 0, y = 0;
                if (this.isAction('forward')) y += 1;
                if (this.isAction('backward')) y -= 1;
                if (this.isAction('left')) x -= 1;
                if (this.isAction('right')) x += 1;
                if (Math.abs(this.touch.lx) > 0.1) x += this.touch.lx;
                if (Math.abs(this.touch.ly) > 0.1) y -= this.touch.ly;
                return { x, y };
            }

            getLook() {
                let x = 0;
                if (this.keys['ArrowLeft']) x -= 1;
                if (this.keys['ArrowRight']) x += 1;

                // Mouse Look
                if (Math.abs(this.mouse.x) > 0.001) {
                    let mx = this.mouse.x;
                    if (SETTINGS.invertX) mx = -mx;
                    x += mx * 2.0;
                }

                if (Math.abs(this.touch.rx) > 0.1) x += this.touch.rx * 2.0;

                this.mouse.x = 0; // Reset frame delta

                return { x };
            }

            isFiring() { return this.keys['Space'] || this.buttons.fire; }
        }

        function shadeColor(color, percent) {
            // Parses hex, shades it, returns new hex
            if (color.length !== 7) return color;
            let R = parseInt(color.substring(1,3),16);
            let G = parseInt(color.substring(3,5),16);
            let B = parseInt(color.substring(5,7),16);

            R = parseInt(R * (100 + percent) / 100);
            G = parseInt(G * (100 + percent) / 100);
            B = parseInt(B * (100 + percent) / 100);

            R = (R<255)?R:255;
            G = (G<255)?G:255;
            B = (B<255)?B:255;

            const RR = ((R.toString(16).length==1)?"0"+R.toString(16):R.toString(16));
            const GG = ((G.toString(16).length==1)?"0"+G.toString(16):G.toString(16));
            const BB = ((B.toString(16).length==1)?"0"+B.toString(16):B.toString(16));

            return "#"+RR+GG+BB;
        }

        window.onload = () => new Game();
    </script>
</body>
</html>
